<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>AQS源码解析</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="一个基于VuePress的 知识管理&amp;博客 主题">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.be1758fe.css" as="style"><link rel="preload" href="/assets/js/app.55b11924.js" as="script"><link rel="preload" href="/assets/js/2.73d4029d.js" as="script"><link rel="preload" href="/assets/js/42.772aa8ee.js" as="script"><link rel="prefetch" href="/assets/js/10.2b19092b.js"><link rel="prefetch" href="/assets/js/11.5d2d3328.js"><link rel="prefetch" href="/assets/js/12.758d1773.js"><link rel="prefetch" href="/assets/js/13.83080798.js"><link rel="prefetch" href="/assets/js/14.cad064bf.js"><link rel="prefetch" href="/assets/js/15.ce67be64.js"><link rel="prefetch" href="/assets/js/16.7c331707.js"><link rel="prefetch" href="/assets/js/17.353aa3a5.js"><link rel="prefetch" href="/assets/js/18.812e388f.js"><link rel="prefetch" href="/assets/js/19.bea0f1aa.js"><link rel="prefetch" href="/assets/js/20.ae2220ed.js"><link rel="prefetch" href="/assets/js/21.8b82ed1e.js"><link rel="prefetch" href="/assets/js/22.97d63dbe.js"><link rel="prefetch" href="/assets/js/23.79033cfd.js"><link rel="prefetch" href="/assets/js/24.96ca227f.js"><link rel="prefetch" href="/assets/js/25.90813872.js"><link rel="prefetch" href="/assets/js/26.b18aba27.js"><link rel="prefetch" href="/assets/js/27.f9995d4b.js"><link rel="prefetch" href="/assets/js/28.31b6825c.js"><link rel="prefetch" href="/assets/js/29.94237f71.js"><link rel="prefetch" href="/assets/js/3.ceab01f3.js"><link rel="prefetch" href="/assets/js/30.8269ef59.js"><link rel="prefetch" href="/assets/js/31.c18e7c44.js"><link rel="prefetch" href="/assets/js/32.06171ecb.js"><link rel="prefetch" href="/assets/js/33.a33f1b11.js"><link rel="prefetch" href="/assets/js/34.3e39f435.js"><link rel="prefetch" href="/assets/js/35.6d245714.js"><link rel="prefetch" href="/assets/js/36.c4063459.js"><link rel="prefetch" href="/assets/js/37.5bbb13b5.js"><link rel="prefetch" href="/assets/js/38.924e8c19.js"><link rel="prefetch" href="/assets/js/39.e99c2fc3.js"><link rel="prefetch" href="/assets/js/4.a6d97bd6.js"><link rel="prefetch" href="/assets/js/40.b8d5bbf4.js"><link rel="prefetch" href="/assets/js/41.ea4edc48.js"><link rel="prefetch" href="/assets/js/43.bb7e9285.js"><link rel="prefetch" href="/assets/js/44.45df278e.js"><link rel="prefetch" href="/assets/js/45.d55cceca.js"><link rel="prefetch" href="/assets/js/46.0c8c51d9.js"><link rel="prefetch" href="/assets/js/47.0e96e931.js"><link rel="prefetch" href="/assets/js/48.7cd0eba4.js"><link rel="prefetch" href="/assets/js/49.e46e4b79.js"><link rel="prefetch" href="/assets/js/5.2729aef4.js"><link rel="prefetch" href="/assets/js/50.92ba3da6.js"><link rel="prefetch" href="/assets/js/51.0202291b.js"><link rel="prefetch" href="/assets/js/52.f92048a9.js"><link rel="prefetch" href="/assets/js/53.07ceccc9.js"><link rel="prefetch" href="/assets/js/54.4e07b215.js"><link rel="prefetch" href="/assets/js/55.2e2bb8d4.js"><link rel="prefetch" href="/assets/js/56.45e214fe.js"><link rel="prefetch" href="/assets/js/57.4ce4a530.js"><link rel="prefetch" href="/assets/js/58.f5cb3725.js"><link rel="prefetch" href="/assets/js/59.d876d40f.js"><link rel="prefetch" href="/assets/js/6.18289d2c.js"><link rel="prefetch" href="/assets/js/60.23938f5e.js"><link rel="prefetch" href="/assets/js/61.80196175.js"><link rel="prefetch" href="/assets/js/62.5f2ced9c.js"><link rel="prefetch" href="/assets/js/63.424361b5.js"><link rel="prefetch" href="/assets/js/64.63e35c1a.js"><link rel="prefetch" href="/assets/js/65.dc44ac45.js"><link rel="prefetch" href="/assets/js/66.bac24f77.js"><link rel="prefetch" href="/assets/js/67.f2e38f54.js"><link rel="prefetch" href="/assets/js/68.8eab7a58.js"><link rel="prefetch" href="/assets/js/69.73bfbfca.js"><link rel="prefetch" href="/assets/js/7.9ce784ab.js"><link rel="prefetch" href="/assets/js/8.5a0ba8cc.js"><link rel="prefetch" href="/assets/js/9.e78313b5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.be1758fe.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/259a4b/" class="nav-link">文章</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">联系我</a></div> <a href="https://github.com/2382546457" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/259a4b/" class="nav-link">文章</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">联系我</a></div> <a href="https://github.com/2382546457" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/259a4b/" class="sidebar-link">说明</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java并发</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/56d8fa/" class="sidebar-link">CAS</a></li><li><a href="/pages/6c8c00/" aria-current="page" class="active sidebar-link">AQS源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_1-简述" class="sidebar-link">1. 简述</a></li><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_2-aqs-的一些重要属性" class="sidebar-link">2. AQS 的一些重要属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_2-1-node" class="sidebar-link">2.1 Node</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_2-2-同步队列" class="sidebar-link">2.2 同步队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_2-3-等待队列" class="sidebar-link">2.3 等待队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_2-4-state状态值" class="sidebar-link">2.4 state状态值</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_2-5-小结" class="sidebar-link">2.5 小结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_3-线程加锁失败后" class="sidebar-link">3. 线程加锁失败后</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_3-1-将当前线程加入同步队列" class="sidebar-link">3.1 将当前线程加入同步队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_3-2-将当前线程阻塞" class="sidebar-link">3.2 将当前线程阻塞</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_4-释放锁后" class="sidebar-link">4. 释放锁后</a></li><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_5-condition" class="sidebar-link">5. Condition</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_5-1-condition-await" class="sidebar-link">5.1 Condition.await()</a></li><li class="sidebar-sub-header level3"><a href="/pages/6c8c00/#_5-2-condition-signal" class="sidebar-link">5.2 Condition.signal()</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/6c8c00/#_5-总结" class="sidebar-link">5. 总结</a></li></ul></li><li><a href="/pages/5031c2/" class="sidebar-link">ReentrantLock 源码解析</a></li><li><a href="/pages/6cfda5/" class="sidebar-link">ReentrantReadWriteLock 源码解析</a></li><li><a href="/pages/0776e3/" class="sidebar-link">原子类</a></li><li><a href="/pages/937dd3/" class="sidebar-link">FutureTask源码解析</a></li><li><a href="/pages/c1826d/" class="sidebar-link">FutureTask中的适配器模式</a></li><li><a href="/pages/671511/" class="sidebar-link">线程池</a></li><li><a href="/pages/79cb1d/" class="sidebar-link">线程池源码解析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>踩坑</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实习小结</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>文章</span></li><li data-v-06225672><span data-v-06225672>Java并发</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/2382546457" target="_blank" title="作者" class="beLink" data-v-06225672>何</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-12-21</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">AQS源码解析<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="_1-简述"><a href="#_1-简述" class="header-anchor">#</a> 1. 简述</h2> <p>JUC 包下的很多类都依靠 AQS，在知道 AQS 是一个抽象类之后，我一度以为 <code>AQS是JUC的基石</code> 这句话的意思是：JUC包下很多类都实现/继承了 AQS，比如 ReentrantLock 实现了 AQS... 但是我错了。</p> <p><img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726160739381.png" alt="image-20230726160739381"></p> <p>可以看到，AQS 有很多名为 <code>Sync</code>的实现类，这些 Sync 分布在不同的类中，那么  <code>AQS是JUC的基石</code> 的意思就应该是：<strong>当一个工具类想要使用 AQS 提供的基本功能时，会写一个内部类 Sync 继承 AQS</strong>。</p> <p>再次强调 ：<font color="green"><strong>AQS 是一个工具，它没有加锁功能</strong></font>。它的许多实现类（大多叫做 Sync）实现了加锁功能，比如公平加锁、非公平加锁、加读写锁、加公平锁.....</p> <p>AQS 提供了什么功能呢？<font color="green"><strong>如果没有抢到锁就会让线程阻塞等待</strong></font>。</p> <p>当某个类想要使用 AQS 提供的基本功能时，只需要继承它并实现那些还没有实现的方法就可以，这是典型的<code>模板方法设计模式</code>。</p> <p>AQS 本身没有抢锁功能，大多数文章会从 ReentrantLock 入手，但是这会让读者乱套，初学者很容易对 ReentrantLock 与 AQS 迷迷糊糊分不清，所以本篇文章会抽象表达 “加锁” 这个概念，也就是不讲解加锁功能，而是简略的以 “某线程抢锁失败” 来表达。</p> <p>等把 AQS 提供的功能介绍清楚了再介绍 ReentrantLock、CountDownLatch 对它的实现。</p> <h2 id="_2-aqs-的一些重要属性"><a href="#_2-aqs-的一些重要属性" class="header-anchor">#</a> 2. AQS 的一些重要属性</h2> <h3 id="_2-1-node"><a href="#_2-1-node" class="header-anchor">#</a> 2.1 Node</h3> <p>现在可以抽空看一下目录，是不是有<code>同步队列</code>和<code>等待队列</code>这两个小标题？这个Node类就是组成同步队列和阻塞队列的节点。原本想要在同步队列中直接将 Node 引出，但是会因此让文章变得混乱，所以我决定先介绍Node。</p> <p>AQS中有一个静态内部类：<code>Node</code>。这个Node可以抽象为线程，也许说它就代表着线程更加妥当。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此Node代表的线程</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">// pre 和 next 构成了双向链表，组成AQS的同步队列</span>
    <span class="token comment">// 此Node的前一个结点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
	<span class="token comment">// 此Node的后一个节点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
    <span class="token comment">// nextWaiter 构成了单向链表，组成了AQS的等待队列</span>
    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>
    <span class="token comment">// 节点的状态</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>next 和 prev 用于实现同步队列（基于双向链表）</li> <li>nextWaiter 用于实现等待队列（基于单链表），这个 nextWaiter 用于 Condition.await()</li></ul> <p>因为 Node 代表着线程，所以它提供了几个状态值来代表线程在队列中的状态 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Node的状态默认为 0</span>

<span class="token comment">// 此任务已取消</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CANCELLED</span> <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 当前节点的下一个节点挂起了</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SIGNAL</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 当前节点在等待队列中</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONDITION</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">// 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PROPAGATE</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><p>谁拥有这些状态值呢？<strong>waitStatus</strong></p> <p>线程都是以 Node 形式保存在 AQS 中的，Node中提供了几种状态供线程使用，例如 已取消（1）、默认（0）、挂起（-1）、等待（-2）....</p> <p>同时，如果你正在看源码，还会看到两个属性 :</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 共享模式</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 独占模式</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">EXCLUSIVE</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>SHARED 和 EXCLUSIVE 两个单词的意思很明显 ：共享和独占。</p> <ol><li>独占模式即当锁被某个线程成功获取时，其他线程无法获取到该锁，<strong>同一时间只有一个线程能拿到锁执行</strong>，锁的状态只有0和1两种情况。例如 ReentrantLock，一次只有一个线程可以工作。</li> <li>共享模式即当锁被某个线程成功获取时，其他线程仍然可能获取到该锁，<strong>同一时间有多个线程可以拿到锁协同工作</strong>，锁的状态大于或等于0。例如 CountDownLatch，一次可以有多个线程工作。</li></ol> <h3 id="_2-2-同步队列"><a href="#_2-2-同步队列" class="header-anchor">#</a> 2.2 同步队列</h3> <p>这个同步队列是由双向链表实现的。从上面所说的可以知道，AQS中的同步队列是由Node组成、Node中的prev和next连接。</p> <p>只有节点肯定不行，AQS中有两个属性控制这个双向链表，head 和 tail 。即头和尾。头是一个虚拟节点，它里面的 thread变量 一直是NULL并不会代表哪个线程；尾是有具体意义的，会代表某一个线程。即：头节点无意义，其他节点都代表一个线程。</p> <p><img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726171337940.png" alt="同步队列"></p> <p>注意喽，同步队列的头节点是无意义的，线程封装的节点不能成为头节点，只能成为头节点后的节点。</p> <h3 id="_2-3-等待队列"><a href="#_2-3-等待队列" class="header-anchor">#</a> 2.3 等待队列</h3> <p>Node组成等待队列，Node中的<code>nextWaiter</code>连接成为等待队列。</p> <p><img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726172213584.png" alt="image-20230726172213584"></p> <p>奇怪的是，当我在AQS中寻找与管理同步队列的head和tail类似的属性时并没有找到，但我还是找到了管理等待队列的属性：<code>firstWaiter</code>、<code>lastWaiter</code></p> <p>它在AQS另一个内部类中 ：<code>ConditionObject</code>。</p> <p>说来也是，就 “等待队列” 这个词而言，<code>等待</code>肯定是它的一大特点。那么如何实现等待？一个是Object类中的wait方法，另一个就是 Condition 的 await 方法。那么就好解释了：</p> <blockquote><p>ConditionObject 提供了让 Node 等待的方法，例如 await、signal...通过 Node.nextWaiter 将线程串为一个等待队列，并且使用 firstWaiter 和 lastWaiter 控制/管理 等待队列。</p></blockquote> <p>注意喽，等待队列的 firstWaiter 可不是无意义的哦，线程封装为 Node 后可以成为 firstWaiter</p> <h3 id="_2-4-state状态值"><a href="#_2-4-state状态值" class="header-anchor">#</a> 2.4 state状态值</h3> <p>这是一个非常重要的属性。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
</code></pre></div><p>毕竟AQS提供的是并发支持，有并发就要有锁，那么一个线程怎样才算拿到锁呢？</p> <p>state 不为 0 的时候证明这个锁被占有了。</p> <p>同时，由于 AQS 并没有要求实现类必须怎样怎样，所以实现类们也把 state 用的花里胡哨，例如：</p> <ol><li>在 ReentrantLock 中，state 为 0 代表锁还未被占有，如果为 1 代表被占有，如果大于 1 代表重入。</li> <li>在 CountDownLatch 中，state 代表着任务数量。</li> <li>在 ReentrantReadWriteLock 中，将 state 的 32 个字节均分为两部分，一部分表示读锁，一部表示写锁。</li></ol> <h3 id="_2-5-小结"><a href="#_2-5-小结" class="header-anchor">#</a> 2.5 小结</h3> <ol><li><p>AQS有两个重要的属性：Node和state。</p></li> <li><p>state 是状态值，一般来说代表锁是否被持有，不过具体含义要看实现类如何操作。</p></li> <li><p>共享和独占 ：共享是允许多个线程共同执行任务，独占是同一时间只允许一个线程执行</p></li> <li><p>Node：是线程的代表，线程会被封装为Node在AQS中存在。</p> <p>Node中有三个属性：next、prev、nextWaiter。</p> <ul><li>next和prev连接Node成为<code>同步队列</code>。控制同步队列的属性 head 和 tail 在AQS中。</li> <li>nextWaiter连接Node成为<code>等待队列</code>。控制等待队列的属性 firstWaiter 和 lastWaiter 在 ConditionObject 中（AQS的内部类）</li> <li>（至于同步队列和等待队列到底有什么用，我想在后续慢慢展开。）</li></ul></li></ol> <p><img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726212426652.png" alt="image-20230726212426652"></p> <h2 id="_3-线程加锁失败后"><a href="#_3-线程加锁失败后" class="header-anchor">#</a> 3. 线程加锁失败后</h2> <p>在上面说过，AQS 自身并不提供加锁功能，而是实现了加锁失败后的逻辑。这么做有什么好处呢？</p> <p>程序员可以根据需要进行加锁，比如以下各种锁实现时，想要加锁要满足什么条件：</p> <ol><li>不可重入锁 ：锁不被任何线程持有时才能加锁成功</li> <li>可重入锁 ：锁不被任何线程持有，但是如果是自己持有，还可以加锁</li> <li>公平锁 ：线程抢锁之前先看看有没有其他线程正在等待，没有再抢锁，有就跟在他们后面</li> <li>非公平锁 ：管它呢直接抢，抢不到再说</li> <li>读写锁 ：读锁可共享，写锁需排斥。</li></ol> <p>如果没有 AQS，这些锁在实现的时候都要写一遍 “线程抢锁失败后需要阻塞等待” 的逻辑，代码太冗余了！AQS 大手一挥，我帮你们实现，程序员只要根据现在的情况判断是否抢锁成功就行了，抢锁失败的线程交给我。</p> <p>那么现在就来看看 AQS 如何对待抢锁失败的线程的吧。</p> <p>AQS 需要它的子类实现的方法是 ：tryAcquire()，也就是尝试获取锁，如果获取成功了就没 AQS 要干的事了，但是如果失败，那么就要处理当前线程了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// tryAcquire让子类去实现</span>
    <span class="token comment">// 如果获取锁失败，执行后面的逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token comment">// 将当前线程加入到同步队列中，并且将线程阻塞</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 阻塞停止后，调用该线程的 interrupt方法</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>tryAcquire 方法由子类实现，那么现在来看看 addWaiter 与 acquireQueued 这两个方法</p> <ol><li>addWaiter ：将当前线程封装为 Node 并放入同步队列</li> <li>acquireQueued ：</li></ol> <h3 id="_3-1-将当前线程加入同步队列"><a href="#_3-1-将当前线程加入同步队列" class="header-anchor">#</a> 3.1 将当前线程加入同步队列</h3> <p>步骤分为两大步：构建一个 Node、放到队列尾部。</p> <p>你想把一个 Node 放到双向链表的尾部，大抵是这三步：</p> <div class="language-java extra-class"><pre class="language-java"><code>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
node<span class="token punctuation">.</span>pre <span class="token operator">=</span> tail<span class="token punctuation">;</span>
node <span class="token operator">=</span> tail
</code></pre></div><p>也就是将链表尾节点的 next 指针指向自己，自己的 pre 指针指向尾节点，最后自己变成了尾节点。</p> <p>但是放入队列尾部这个动作说得轻巧，问题就出在这里，当多个 Node 想要挂在同一个尾节点上时，会出现并发情况。但是我懒得画图了😜</p> <p>AQS 解决并发情况是这样做的 ：先将 node.pre = tail，再使用 CAS 将 node 成为尾节点，最后将 node.pre.next = node，如果 CAS 失败，说明现在出现并发情况了，别的线程抢先一步将 Node 变成了尾节点，此线程的 node 只能挂在那个 node 后面了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 调用来源 : addWaiter(Node.EXCLUSIVE)</span>
<span class="token comment">// 使用 Node.EXCLUSIVE 作为 mode 的入参，mode为空。</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将此线程封装为独占模式的 Node</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取阻塞队列的尾节点</span>
    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
   
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果尾节点不为空，把此节点挂在尾节点后面</span>
        <span class="token comment">// 首先执行 node.pre = pred</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
        <span class="token comment">// 然后使用CAS的方式将node设置为尾节点</span>
        <span class="token comment">// 如果设置成功，就可以将之前尾节点的next指向现在的尾节点: pred.next = node</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token comment">// 一般情况下会在这里return</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果前面没有return，说明什么？</span>
    <span class="token comment">// 说明CAS失败了，也就是出现了并发设置尾节点的情况，即: 多个线程设置尾节点，这个线程设置失败了。</span>
    <span class="token comment">// 虽然失败了，那这个节点可以挂在新来的尾节点上啊~ </span>
    <span class="token comment">// 所以这个方法的逻辑就是将此节点挂在新来的尾节点上，就不再详细解释了</span>
    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用 CAS 将尾节点的值从 expect 换成 update</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span><span class="token class-name">Node</span> expect<span class="token punctuation">,</span> <span class="token class-name">Node</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tailOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-2-将当前线程阻塞"><a href="#_3-2-将当前线程阻塞" class="header-anchor">#</a> 3.2 将当前线程阻塞</h3> <p>此时，node 已经成为同步队列中的尾节点了，但是线程还没有阻塞，AQS 要做的就是让抢锁失败的线程阻塞，所以这个方法至关重要。</p> <p>一上来就是死循环，当前节点虽然是尾节点，但是如果它的 pre 是头节点代表啥？代表同步队列中只有它一个线程，那我就得重新抢一下锁了，如果抢失败了我再阻塞。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 拿到当前节点的前一个节点，</span>
            <span class="token comment">// 如果是head节点，可以尝试抢一下锁</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果当前节点的前一个节点是head节点，尝试抢锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果抢锁成功，将此节点变成head傀儡节点</span>
                <span class="token comment">// setHead() 方法首先会将 Node内部的线程置为空，为啥置为空？</span>
                <span class="token comment">// 都抢到锁了，这个线程肯定不需要存在于AQS中了。</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 之前的head节点置为空，方便GC</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> 
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 此节点的上一个节点不是头节点，或者抢锁失败，将当前线程 park 起来</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>
                <span class="token comment">// 检查一下节点的状态，如果已取消就没必要阻塞等待</span>
                <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token comment">// 这个方法将当前线程park起来</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
               <span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将node内部的线程置为空，变成无意义的 head 节点</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    head <span class="token operator">=</span> node<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将当前线程park起来</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ★ 线程阻塞在此处等待唤醒 </span>
    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回对应线程的中断标志位，并且将中断标志位重置变为false</span>
    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意 ：当锁被释放时，只会唤醒同步队列中第一个节点，也就是 head.next。（这个会在释放锁的逻辑中说）</p> <p>当阻塞的线程被唤醒，也就代表此节点是 head.next，那么死循环中的 if 条件就可以走通了，于是此节点会使用 tryAcquire 尝试获取锁，如果获取成功就退出循环，如果获取失败就还要阻塞。</p> <h2 id="_4-释放锁后"><a href="#_4-释放锁后" class="header-anchor">#</a> 4. 释放锁后</h2> <p>AQS当然不会管怎么释放锁，释放锁的逻辑让子类去实现，比如不可重入锁直接释放，可重入锁还要判断一下是否重入。</p> <p>AQS 实现的是之前被阻塞的线程怎么办的逻辑。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 释放锁的逻辑让子类实现</span>
    <span class="token comment">// 一旦释放成功，AQS就开始唤醒同步队列中的第一个节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 拿到头节点</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token comment">// 唤醒头节点后面那个节点</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不出意外的情况下是直接唤醒 head.next 那个线程，但是不出意外的情况下要出意外了 ：</p> <p>head 后的第一个节点为空！或者说它的状态为取消！那么就从同步队列的尾部向前寻找一个有意义的节点将它唤醒，注意只找一个哦。</p> <p>并且有一个小细节 ：如果Node的状态为取消，它不会从同步队列中移除，这个细节在 Condition 中会涉及</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 此时传入的Node为头节点</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 拿到头节点后面的第一个节点</span>
    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 一般来说不会走这里，而是下面那个if，直接将线程唤醒。</span>
    <span class="token comment">// 但是走这里的逻辑是因为啥呢？</span>
    <span class="token comment">// waitStatus在上面有讲解，节点的 waitStatus &gt; 0代表此节点已经取消</span>
    <span class="token comment">// 所以逻辑就是：如果 head.next 为空或者已经取消，就从同步队列的尾部开始往前寻找，</span>
    <span class="token comment">// 直到找到一个没有取消的节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                s <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 直接将这个线程唤醒了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>步骤 ：拿到头节点后的第一个有意义的节点，如果这个节点的状态为取消，说明这个节点刚从等待队列放到同步队列，跳过它从队列的尾部开始找状态正常的，找到之后将它唤醒</p> <p>所有线程的执行都阻塞在 acquireQueued 方法内部，这个你可以向上翻，我有说。</p> <h2 id="_5-condition"><a href="#_5-condition" class="header-anchor">#</a> 5. Condition</h2> <p>可能刚说完 AQS 就说 Condition 会有些割裂感，因为很难想象 Condition 与 AQS 有啥关系，对，有关系，还记得 AQS 的 Node 中有一个成员变量 ：nextWaiter</p> <p>我在之前说过，AQS 本身的逻辑并没有用到这个变量，而是在 ConditionObject 中使用到了，所以 AQS 中第二个队列出现了 ：等待队列</p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <p>请你注意等待队列与同步队列的区别。不要将二者混为一谈</p></div> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token comment">// 此Node代表的线程</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token comment">// 用于同步队列，此Node的前一个结点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
	<span class="token comment">// 用于同步队列，此Node的后一个节点</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
    <span class="token comment">// 用于等待队列，等待队列是一个单向链表组成的队列</span>
    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>
    <span class="token comment">// 节点的状态</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>
    <span class="token comment">// 省略其他变量</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常用的让线程等待的方法有两种 ：</p> <ol><li>Object.wait()</li> <li>Condition.await()</li></ol> <p>虽然实现不一样，但是原理是一样的，线程等待的前提肯定是已经拥有锁了，调用 wait 后会释放锁然后阻塞。调用 signal 将线程从等待状态唤醒，进入阻塞状态，可以抢锁。</p> <h3 id="_5-1-condition-await"><a href="#_5-1-condition-await" class="header-anchor">#</a> 5.1 Condition.await()</h3> <p>如果是你，你会如何借助 AQS 来实现 Condition.await() 呢？不就是释放锁之后阻塞嘛~</p> <ol><li>将此线程封装为 Node 并放入等待队列</li> <li>调用 AQS 的 release 释放锁</li> <li>将当前线程阻塞</li></ol> <p>对，就是这三步，来看看 AQS 中的 ConditionObject 如何实现这三步的 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将当前线程封装为Node，Node的状态为-2，也就是等待，然后放入等待队列</span>
    <span class="token comment">// 这时会将 node.waitStatus 改为 CONDITION</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用 release 方法释放锁</span>
    <span class="token comment">// 这时会将 node.waitStatus 改为 CANCELLED ★ 这里特别重要！！！！！</span>
    <span class="token comment">// 再次强调，这里会将 node.waitStatus 改为 CANCELLED </span>
    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断 Node 节点的状态</span>
    <span class="token comment">// 第一次进入时都会返回false，取反后会进入方法将线程阻塞</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 线程从等待状态恢复后，进入同步队列等待抢锁，这里的逻辑就是上面说过了的。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>
        interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_5-2-condition-signal"><a href="#_5-2-condition-signal" class="header-anchor">#</a> 5.2 Condition.signal()</h3> <p>如果是你，你会如何借助 AQS 来实现 Condition.signal() 呢？不就是唤醒锁、把它加入同步队列嘛~</p> <p>Condition.signal() 会唤醒在等待队列中等待时间最长的节点（首节点）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 传入的是等待队列的头节点（线程是可以成为头节点的）</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment">// 一般不会走这里</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 将头节点的next指针置为空</span>
        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 将该节点加入同步队列尾部</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 刚刚在 await方法中，我特别强调了，fullyRelease 方法会将节点的状态改为取消</span>
    <span class="token comment">// 也就是 node.waitStatus = 1, 即 ws = 1</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>思考 ：为啥调用 await() 方法让线程释放锁后，线程 Node 的状态会变成取消（node.waitStatus = 1）呢？</p> <p>因为 signal 方法的步骤为 ：</p> <ol><li>将 node 放入同步队列</li> <li>将线程唤醒</li></ol> <p>将 node 放入同步队列后，万一被唤醒了怎么办？那就要通过一些手段防止这种概率特别小的情况出现，也就是线程调用 await() 进入等待之前先将 Node 的状态变成 取消，那么就不会被误唤醒！真叼啊。</p> <p>Condition 的 singalAll 方法，相当于对等待队列的每个节点均执行一次 singal 方法，效果就是将等待队列中所有节点全部移动到同步队列，并唤醒每个节点的线程。</p> <h2 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h2> <p>至此，AQS 的核心功能已经说完了，没有讲加锁、释放锁？因为加锁、释放锁的逻辑本来就不是 AQS 要完成的呀。</p> <p>所以加锁与释放锁我会在 ReentrantLock、CountDownLatch、ReadWriteLock 中讲。</p></div></div>  <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/02/28, 21:50:33</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/56d8fa/" class="prev">CAS</a></span> <span class="next"><a href="/pages/5031c2/">ReentrantLock 源码解析</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="3175543112@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/2382546457" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2024
    <span>何 | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.55b11924.js" defer></script><script src="/assets/js/2.73d4029d.js" defer></script><script src="/assets/js/42.772aa8ee.js" defer></script>
  </body>
</html>
