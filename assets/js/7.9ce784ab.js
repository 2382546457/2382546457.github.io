(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{332:function(a,t,s){"use strict";s.r(t);var n=s(7),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("关于 mmap、sendfile 的知识，参见 ："),t("a",{attrs:{href:"https://2382546457.github.io/pages/dbd03e/",target:"_blank",rel:"noopener noreferrer"}},[a._v("零拷贝"),t("OutboundLink")],1),a._v("。这篇文章介绍了零拷贝的知识，也讲解了 mmap、sendfile 对于数据传输的优化 以及 它俩的区别。")]),a._v(" "),t("p",[a._v("Java sendfile 的 api 是 transferTo 和 transferFrom 方法。")]),a._v(" "),t("p",[a._v("注意 ：send file 是一个从磁盘到网卡驱动的 IO 优化。反过来，网卡到磁盘，是没有这个优化的。也就是说 transferFrom 方法并没有这种福利。")]),a._v(" "),t("h2",{attrs:{id:"_1-mmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-mmap"}},[a._v("#")]),a._v(" 1. MMAP")]),a._v(" "),t("p",[a._v("MMAP ：将用户缓冲区与内核缓冲区做映射，减少一次CPU拷贝。")]),a._v(" "),t("p",[a._v("在 Java 中调用 MMAP 为 ：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MappedByteBuffer")]),a._v(" mappedBuffer "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n    fileChannel"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("map")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FileChannel"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("MapMode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("READ_WRITE")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" fileChannel"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("size")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("fileChannel.map() 后即可获得映射后的 buffer，接着就可以使用 MMAP 方式进行文件拷贝。")]),a._v(" "),t("p",[a._v("可以使用 mappedBuffer.put() 方法向缓冲区存放数据，再使用 mappedBuffer.force() 刷新到磁盘。")]),a._v(" "),t("p",[a._v("mmap为何可以减少一次CPU拷贝，在零拷贝那一章已经介绍过了，不在介绍了。")]),a._v(" "),t("h2",{attrs:{id:"_2-堆外内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆外内存"}},[a._v("#")]),a._v(" 2. 堆外内存")]),a._v(" "),t("p",[a._v("Java 中还有一种方式可以提高文件拷贝的效率 ：堆外内存。")]),a._v(" "),t("p",[a._v("实际上这种方式并不是零拷贝，我们知道，Java中使用的内存大部分都在堆中，堆受Java堆内存管理的控制。")]),a._v(" "),t("p",[a._v("而堆外内存是直接在堆的外面分配内存给你用，不再受 Java堆内存管理机制的约束，不存在频繁的移动或者清理。通常会与mmap结合在一起使用，所以Java 提供了一个类 ："),t("code",[a._v("DirectBuffer")])]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DirectBuffer")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("address")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("attachment")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Cleaner")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("cleaner")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("这是一个接口，其中 address 是申请的堆外内存的地址。这个类拥有很多实现类，拿最典型的 "),t("code",[a._v("DirectByteBuffer")]),a._v("来说，它既实现了 "),t("code",[a._v("DirectBuffer")]),a._v("，拥有分配堆外内存的能力，又实现了"),t("code",[a._v("MappedByteBuffer")]),a._v("，拥有了内存映射的能力。")]),a._v(" "),t("p",[a._v("堆外内存怎么分配呢？用学过的C语言来说，大概就是 malloc 一下，把申请的地址给 address变量。")]),a._v(" "),t("h2",{attrs:{id:"_3-send-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-send-file"}},[a._v("#")]),a._v(" 3. send file")]),a._v(" "),t("p",[a._v("说 senfile 其实也不合适，Java对于send file 的实现中，按照不同的使用情况使用了不同的零拷贝方式，其中两个关键的 api ："),t("code",[a._v("transferTo")]),a._v("、"),t("code",[a._v("transferFrom")]),a._v("。它俩在 FileChannel 中。")]),a._v(" "),t("p",[a._v("其中只有 "),t("font",{attrs:{color:"Blue"}},[t("strong",[a._v("transferTo")])]),a._v(" 用到了send file，而且想要触发 send file 是有条件的，具体往下看。")],1),a._v(" "),t("h3",{attrs:{id:"_3-1-transferfrom-细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-transferfrom-细节"}},[a._v("#")]),a._v(" 3.1 transferFrom 细节")]),a._v(" "),t("p",[a._v("transferFrom的底层其实是两种实现方式 ：")]),a._v(" "),t("ol",[t("li",[a._v("MMAP")]),a._v(" "),t("li",[a._v("堆外内存")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/img.png",alt:"transferFrom"}})]),a._v(" "),t("p",[a._v("从代码可以看出来，使用transferFrom后，判断传入的 channel 类型，")]),a._v(" "),t("ul",[t("li",[a._v("如果是普通的 FileChannel 实现类，那么使用mmap做映射。")]),a._v(" "),t("li",[a._v("如果用的是 非FileChannel，即SocketChannel相关实现类，用堆外内存完成。")])]),a._v(" "),t("h4",{attrs:{id:"_3-1-1-mmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-mmap"}},[a._v("#")]),a._v(" 3.1.1 MMAP")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/img_1.png",alt:"mmap"}})]),a._v(" "),t("p",[a._v("方法的名字叫做 "),t("code",[a._v("transferFromFileChannel")])]),a._v(" "),t("p",[a._v("简单来讲，在一个循环中，每次都是将源文件根据 position 映射为一个 mmap，最大8M，逐次的将数据写入目标文件中。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("privatet "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("transferFromFileChannel")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FileChannelImpl")]),a._v(" src"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" position"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" count"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 省略部分代码")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// remaining: 需要拷贝的数据剩余的字节。")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("remaining "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0L")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" size "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Math")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("min")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("remaining"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1024")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1024")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MappedByteBuffer")]),a._v(" bb "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" src"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("map")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MapMode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("READ_ONLY")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" size"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 写入n个字节，并将源文件和目标文件的下标更改")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" n "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("write")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("bb"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" position"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n            position "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n            remaining "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-=")]),a._v(" n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("finally")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 取消映射")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("unmap")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("bb"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h4",{attrs:{id:"_3-1-2-堆外内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-堆外内存"}},[a._v("#")]),a._v(" 3.1.2 堆外内存")]),a._v(" "),t("p",[a._v("transferFrom堆外内存的细节：")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/img_2.png",alt:"堆外内存"}})]),a._v(" "),t("p",[a._v("如果我们使用的是 SocketChannelImpl，就会走堆外内存，也是在一个循环中写入，每次最大8k。用完尽量回收重新利用。")]),a._v(" "),t("h4",{attrs:{id:"_3-1-3-transferfrom-方法小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-transferfrom-方法小结"}},[a._v("#")]),a._v(" 3.1.3 transferFrom 方法小结")]),a._v(" "),t("ol",[t("li",[a._v("如果是源是 FileChannelImpl 类型， 就走 mmap ，循环映射 8MB 刷进磁盘。")]),a._v(" "),t("li",[a._v("如果源是 SocketChannelImpl 类型，就走堆外内存。简单来说，就是循环放进堆外内存，每次 8kb 刷进磁盘。注意：关于这个堆外内存，是用到了缓存池子的（堆外内存池化是常用优化手段），这个池子是个数组，长度是 16，使用 ThreadLocal 提升性能，每次获取，只要目标数组比池子中的 ByteBuffer 的 capacity 小即可使用，用完就还，如果满了，就调用 unsafe 释放。")])]),a._v(" "),t("h3",{attrs:{id:"_3-2-transferto-细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-transferto-细节"}},[a._v("#")]),a._v(" 3.2 transferTo 细节")]),a._v(" "),t("p",[a._v("transferTo 方法很有意思，先简单说下结论：")]),a._v(" "),t("ol",[t("li",[a._v("如果 OS 支持 send file（windows 不支持），就执行 system call。")]),a._v(" "),t("li",[a._v("如果 OS 不支持，就走 mmap。")]),a._v(" "),t("li",[a._v("如果 mmap 失败，就走 堆外内存。")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/img_12.png",alt:"transferTo"}})]),a._v(" "),t("blockquote",[t("p",[a._v("看了 send file 的 Java 层面实现，这里总结一下，只有 transferTo 用到了 send file，而且还是有条件的，具体，本文第二部分已经给出。")]),a._v(" "),t("p",[a._v("而 transferFrom 方法则是很普通的使用 mmap 或者 堆外内存，似乎我们有可以自己实现，反而性能可能会更好，例如我们使用更大的缓存，而不必循环多次，我们可以使用更大的 mmap 映射，而不是 8Mb，每次都需要 clean 再重新 mapping。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);