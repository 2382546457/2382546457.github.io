(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{359:function(_,v,t){"use strict";t.r(v);var o=t(7),r=Object(o.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-cache"}},[_._v("#")]),_._v(" 1. Cache")]),_._v(" "),v("p",[_._v("为什么 CPU 要有缓存？")]),_._v(" "),v("p",[_._v("CPU 要从内存中取数据，但是 CPU 太快了，内存太慢了，速度差异过大导致 CPU 的性能无法利用。所以操作系统使用 Cache 作为 CPU 与内存之间的缓存。就像 Redis 在 Java程序与MySQL之间充当缓存作用似的。")]),_._v(" "),v("p",[_._v("Cache 通常分为三级 ：L1、L2、L3。级别越低，离 CPU 越近，速度越快，但是存储容量越小。")]),_._v(" "),v("p",[_._v("在多核 CPU 中，每个 CPU 都有各自的 L1 与 L2，而L3是所有 CPU 共享的 。")]),_._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/CPU-Cache.png",alt:"img"}}),_._v(" "),v("p",[v("strong",[_._v("Cache 是由很多个 Cache Line 组成的")]),_._v("，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：")]),_._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802120745.png"}}),_._v(" "),v("p",[_._v("事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。")]),_._v(" "),v("p",[_._v("有两种写方式：")]),_._v(" "),v("ol",[v("li",[_._v("写直达 ："),v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Write Through")])]),_._v("，写入数据时不仅往缓存中写，还要往内存中写。")],1),_._v(" "),v("li",[_._v("写回 ："),v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Write Back")])]),_._v("，写数据时只往缓存中写，并把数据标记为脏数据，写数据时遇到脏数据就会将脏数据同步到内存。")],1)]),_._v(" "),v("h2",{attrs:{id:"_2-缓存一致性问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存一致性问题"}},[_._v("#")]),_._v(" 2. 缓存一致性问题")]),_._v(" "),v("p",[_._v("现在的 CPU 都是多核的，由于 L1 与 L2 是 CPU 独自拥有的，那么就会带来缓存一致性问题，如果不能解决缓存一致性问题，那就会造成结果错误。")]),_._v(" "),v("p",[_._v("那么什么是缓存一致性问题呢？为什么会出现缓存一致性问题？")]),_._v(" "),v("p",[_._v("假如现在又两个核：CPU "),v("strong",[_._v("A")]),_._v(" 与 CPU "),v("strong",[_._v("B")]),_._v("，在他们的 L1 中都有一个变量 i = 0。")]),_._v(" "),v("p",[_._v("现在 A 将它修改为1，还没来的及刷到内存中就被 B 读取了，B 读取的数据 i = 0。")]),_._v(" "),v("p",[_._v("但是 B 比 A 执行的晚，A 又把 i 改了，那么 B 得到的 i 理应为 1。")]),_._v(" "),v("p",[_._v("这就是缓存一致性问题。")]),_._v(" "),v("p",[_._v("想要解决这个问题，就要保证以下两点 ：")]),_._v(" "),v("blockquote",[v("ol",[v("li",[v("em",[v("strong",[_._v("写传播")])]),_._v(" ：一个 CPU 修改了共享变量，要 "),v("strong",[_._v("通知")]),_._v(" 其他所有 CPU。")]),_._v(" "),v("li",[v("em",[v("strong",[_._v("事物的串行化")])]),_._v(" ：这个 “通知” 被 不同CPU 接收的顺序应该相同。")])])]),_._v(" "),v("p",[_._v("第一点很容易理解，一个 CPU 修改了共享变量，在刷新到内存之前就要通知别的 CPU，以免出现缓存不一致问题。")]),_._v(" "),v("p",[_._v("第二点有点犯迷糊，来举个例子：")]),_._v(" "),v("p",[_._v("CPU A 发出了两条通知 ："),v("font",{attrs:{color:"Orange"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("100")])])]),_._v("、"),v("font",{attrs:{color:"Purple"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("200")])])])],1),_._v(" "),v("p",[_._v("如果出现以下情况，那么最终结果就会导致不一样：")]),_._v(" "),v("ul",[v("li",[_._v("CPU B 接收的通知顺序为 ："),v("font",{attrs:{color:"Purple"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("200")])])]),_._v("、"),v("font",{attrs:{color:"Orange"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("100")])])]),_._v("。"),v("br"),_._v("\n在 CPU B 中，i 的最终结果为 "),v("font",{attrs:{color:"Orange"}},[_._v("100")])],1),_._v(" "),v("li",[_._v("CPU C 接收的通知顺序为 ："),v("font",{attrs:{color:"Orange"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("100")])])]),_._v("、"),v("font",{attrs:{color:"Purple"}},[v("strong",[_._v("A")]),_._v(" 将 i 修改为 "),v("em",[v("strong",[_._v("200")])])]),_._v("。"),v("br"),_._v("\n在 CPU C 中，i 的最终结果为 "),v("font",{attrs:{color:"Purple"}},[_._v("200")])],1)]),_._v(" "),v("p",[_._v("所以，我们要保证 B 号核心和 C 号核心都能看到"),v("strong",[_._v("相同顺序的数据变化")]),_._v("。")]),_._v(" "),v("p",[_._v("接下来看一下 CPU 是如何实现 "),v("strong",[_._v("写传播")]),_._v(" 和 "),v("strong",[_._v("事务的串行化")]),_._v(" 的。")]),_._v(" "),v("h2",{attrs:{id:"_3-总线嗅探"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-总线嗅探"}},[_._v("#")]),_._v(" 3. 总线嗅探")]),_._v(" "),v("p",[_._v("写传播机制很简单 ：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。")]),_._v(" "),v("p",[_._v("最常见实现的方式是"),v("strong",[_._v("总线嗅探（"),v("em",[_._v("Bus Snooping")]),_._v("）")]),_._v(" ：某个 CPU 更新了数据时会将修改以"),v("strong",[_._v("广播的形式")]),_._v("发送到 总线，而其他 CPU时刻监听总线，一旦发生写信号，立刻检查自己的 Cache 中是否有这个数据，如果有就把这个写操作同步过来。")]),_._v(" "),v("p",[_._v("总线嗅探机制很简单，但是 CPU 要时刻监听总线，这无异于会增加很多负担。并且总线嗅探只能实现写传播，不能实现 事务的串行化。")]),_._v(" "),v("p",[v("strong",[_._v("MESI 协议")]),_._v("就通过 总线嗅探机制 实现了 事务的串行化，做到了缓存的一致性。")]),_._v(" "),v("h2",{attrs:{id:"_4-mesi协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-mesi协议"}},[_._v("#")]),_._v(" 4. MESI协议")]),_._v(" "),v("p",[_._v("MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：")]),_._v(" "),v("ul",[v("li",[v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Modified")])]),_._v("，已修改")],1),_._v(" "),v("li",[v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Exclusive")])]),_._v("，独占")],1),_._v(" "),v("li",[v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Shared")])]),_._v("，共享")],1),_._v(" "),v("li",[v("font",{attrs:{color:"Purple"}},[v("em",[_._v("Invalidated")])]),_._v("，已失效")],1)]),_._v(" "),v("p",[_._v("这四个状态来标记 Cache Line 四个不同的状态。")]),_._v(" "),v("p",[_._v("「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。如果 CPU 中某个数据是已修改，那么可以直接对这个数据写，不需要通知其他 CPU。")]),_._v(" "),v("p",[_._v("「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。")]),_._v(" "),v("p",[_._v("「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。")]),_._v(" "),v("p",[_._v("「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。")]),_._v(" "),v("p",[_._v("另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。")]),_._v(" "),v("p",[_._v("那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。")]),_._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[_._v("那么MESI如何实现事务的串行化呢？")]),_._v(" "),v("p",[v("strong",[_._v("当一个处理器要修改一个缓存行时，它首先将该缓存行的状态设置为修改状态，然后将该缓存行的数据复制到自己的缓存中。\n此时，其他处理器无法访问该缓存行。其他处理器如果要访问该缓存行，必须先将其状态设置为无效，然后从主存中读取最新的数据。\n这样，每个处理器都可以按照顺序执行事务，保证了事务的串行化。")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);