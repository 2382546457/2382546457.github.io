(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{346:function(e,s,t){"use strict";t.r(s);var v=t(7),_=Object(v.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis哨兵集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis哨兵集群"}},[e._v("#")]),e._v(" Redis哨兵集群")]),e._v(" "),s("p",[e._v("在上一篇"),s("RouterLink",{attrs:{to:"/02.文章/10.Redis/40.Redis主从集群原理.html"}},[e._v("Redis主从集群原理")]),e._v("中，我们学习了主从架构，明白了使用主从集群保证系统高可用的原理，但是在结尾也强调了一个问题：")],1),e._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[e._v("主从集群的缺点")]),e._v(" "),s("p",[e._v("在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，"),s("strong",[e._v("单点问题没有解决")]),e._v("。")])]),e._v(" "),s("p",[e._v("怎么解决呢？我们可以借鉴ZooKeeper的做法，如果主节点宕机，在诸多从节点中选一个当主节点就行了。那么谁来选呢？这就是本篇将要学习的内容："),s("strong",[e._v("哨兵")]),e._v("。")]),e._v(" "),s("h2",{attrs:{id:"_1-什么是哨兵"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是哨兵"}},[e._v("#")]),e._v(" 1. 什么是哨兵")]),e._v(" "),s("p",[e._v("哨兵模式是Redis的高可用方式，哨兵节点也是一个Redis节点，不过它不提供数据读写服务，主要用来监控Redis的所有节点。")]),e._v(" "),s("p",[e._v("Redis哨兵的作用：")]),e._v(" "),s("ol",[s("li",[s("strong",[e._v("监视")]),e._v(" ：哨兵会不断检查主节点与从节点是否正常运行。")]),e._v(" "),s("li",[s("strong",[e._v("提醒 ​")]),e._v("：Sentine充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis客户端。")]),e._v(" "),s("li",[s("strong",[e._v("自动故障迁移")]),e._v(" ：如果master出现故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。")])]),e._v(" "),s("p",[e._v("当部署Redis主从集群后，可以再部署哨兵集群用于监视主从集群：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230701203848-q7woevj.png",alt:"image"}})]),e._v(" "),s("p",[e._v("从图中可以看出来，哨兵也可以是一个集群，你是来监控别人的，结果你自己挂了，这不笑话吗。")]),e._v(" "),s("h2",{attrs:{id:"_2-监控"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-监控"}},[e._v("#")]),e._v(" 2. 监控")]),e._v(" "),s("p",[e._v("Sentinel基于心跳机制检测服务状态，每隔1s向集群中的每一个节点发送ping命令，如果节点回复证明它没问题，如果 master 节点回复 PING 命令的时间超过 down-after-milliseconds 设定的阈值（默认30s），则这个节点会被 sentinel 标记为主观下线，因为这个ping命令可能因为网络延迟没有及时收到回复，所以这是此哨兵主观认为节点下线了。")]),e._v(" "),s("p",[e._v("当sentinel 哨兵节点将节点标记为主观下线后，会向其余所有的 sentinel 发送sentinel is-master-down-by-addr消息，询问其他sentinel是否同意该节点下线，如果超过规定数量(默认一半)的setinel同意，也就是超过一般数量的setinel都认为这个节点主观下线，那么它就会被标记为客观下线。")]),e._v(" "),s("ul",[s("li",[e._v("主观下线 ：如果某setinel发现某节点未在规定时间内响应，则认为该节点主观下线。")]),e._v(" "),s("li",[e._v("客观下线 ：若超过指定数量的sentinel都认为该节点主观下线，则该节点客观下线，会触发通知服务将该节点的情况通知给客户端。（指定数量最好设置为哨兵数量的一半多）")])]),e._v(" "),s("h2",{attrs:{id:"_3-自动故障迁移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-自动故障迁移"}},[e._v("#")]),e._v(" 3. "),s("strong",[e._v("自动故障迁移")])]),e._v(" "),s("p",[e._v("也就是重新选举主节点。")]),e._v(" "),s("p",[e._v("一旦发现 master 故障，sentinel 需要在slave中选择一个作为新的master。选举的依据：")]),e._v(" "),s("ol",[s("li",[e._v("选择优先级最高的节点，通过sentinel配置文件中的replica-priority配置项，这个参数越小，表示优先级越高")]),e._v(" "),s("li",[e._v("如果第一步中的优先级相同，选择offset最大的，offset表示主节点向从节点同步数据的偏移量，越大表示同步的数据越多")]),e._v(" "),s("li",[e._v("如果第二步offset也相同，选择run id较小的")])]),e._v(" "),s("p",[e._v("当选中了其中一个slave为新的master (假如为slave1)后，故障的转移过程如下：")]),e._v(" "),s("ul",[s("li",[e._v("sentinel集群给slave1发送slaveof no one命令，让该节点称为master。")]),e._v(" "),s("li",[e._v("sentinel集群给其他节点发送广播消息，让其他slave节点称为新master的从节点，开始从新的master中同步数据。")]),e._v(" "),s("li",[e._v("sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点。")])]),e._v(" "),s("h2",{attrs:{id:"_4-sentinel选举领导者"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-sentinel选举领导者"}},[e._v("#")]),e._v(" 4. sentinel选举领导者")]),e._v(" "),s("p",[e._v("其实上面的描述并不准确，故障转移是某一个sentinel节点做的，而不是整个sentinel集群做的，那么谁来做这件事呢？一个sentinel集群是有一个头sentinel的，由它来完成主节点的选举。")]),e._v(" "),s("p",[e._v("当主节点被客观下线后，各个哨兵节点会选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。")]),e._v(" "),s("p",[e._v("监视该主节点的所有哨兵都有可能称为领导者，选举使用Raft算法，在没有数据可以进行比较的情况下，Raft的选举更像是先到先得：在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程可以查阅"),s("strong",[e._v("Raft算法")]),e._v("。")]),e._v(" "),s("p",[e._v("‍")])])}),[],!1,null,null,null);s.default=_.exports}}]);