(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{368:function(t,s,a){"use strict";a.r(s);var n=a(7),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-简述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-简述"}},[t._v("#")]),t._v(" 1. 简述")]),t._v(" "),s("p",[t._v("JUC 包下的很多类都依靠 AQS，在知道 AQS 是一个抽象类之后，我一度以为 "),s("code",[t._v("AQS是JUC的基石")]),t._v(" 这句话的意思是：JUC包下很多类都实现/继承了 AQS，比如 ReentrantLock 实现了 AQS... 但是我错了。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726160739381.png",alt:"image-20230726160739381"}})]),t._v(" "),s("p",[t._v("可以看到，AQS 有很多名为 "),s("code",[t._v("Sync")]),t._v("的实现类，这些 Sync 分布在不同的类中，那么  "),s("code",[t._v("AQS是JUC的基石")]),t._v(" 的意思就应该是："),s("strong",[t._v("当一个工具类想要使用 AQS 提供的基本功能时，会写一个内部类 Sync 继承 AQS")]),t._v("。")]),t._v(" "),s("p",[t._v("再次强调 ："),s("font",{attrs:{color:"green"}},[s("strong",[t._v("AQS 是一个工具，它没有加锁功能")])]),t._v("。它的许多实现类（大多叫做 Sync）实现了加锁功能，比如公平加锁、非公平加锁、加读写锁、加公平锁.....")],1),t._v(" "),s("p",[t._v("AQS 提供了什么功能呢？"),s("font",{attrs:{color:"green"}},[s("strong",[t._v("如果没有抢到锁就会让线程阻塞等待")])]),t._v("。")],1),t._v(" "),s("p",[t._v("当某个类想要使用 AQS 提供的基本功能时，只需要继承它并实现那些还没有实现的方法就可以，这是典型的"),s("code",[t._v("模板方法设计模式")]),t._v("。")]),t._v(" "),s("p",[t._v("AQS 本身没有抢锁功能，大多数文章会从 ReentrantLock 入手，但是这会让读者乱套，初学者很容易对 ReentrantLock 与 AQS 迷迷糊糊分不清，所以本篇文章会抽象表达 “加锁” 这个概念，也就是不讲解加锁功能，而是简略的以 “某线程抢锁失败” 来表达。")]),t._v(" "),s("p",[t._v("等把 AQS 提供的功能介绍清楚了再介绍 ReentrantLock、CountDownLatch 对它的实现。")]),t._v(" "),s("h2",{attrs:{id:"_2-aqs-的一些重要属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-aqs-的一些重要属性"}},[t._v("#")]),t._v(" 2. AQS 的一些重要属性")]),t._v(" "),s("h3",{attrs:{id:"_2-1-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-node"}},[t._v("#")]),t._v(" 2.1 Node")]),t._v(" "),s("p",[t._v("现在可以抽空看一下目录，是不是有"),s("code",[t._v("同步队列")]),t._v("和"),s("code",[t._v("等待队列")]),t._v("这两个小标题？这个Node类就是组成同步队列和阻塞队列的节点。原本想要在同步队列中直接将 Node 引出，但是会因此让文章变得混乱，所以我决定先介绍Node。")]),t._v(" "),s("p",[t._v("AQS中有一个静态内部类："),s("code",[t._v("Node")]),t._v("。这个Node可以抽象为线程，也许说它就代表着线程更加妥当。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此Node代表的线程")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// pre 和 next 构成了双向链表，组成AQS的同步队列")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此Node的前一个结点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此Node的后一个节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// nextWaiter 构成了单向链表，组成了AQS的等待队列")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" nextWaiter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点的状态")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" waitStatus"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ul",[s("li",[t._v("next 和 prev 用于实现同步队列（基于双向链表）")]),t._v(" "),s("li",[t._v("nextWaiter 用于实现等待队列（基于单链表），这个 nextWaiter 用于 Condition.await()")])]),t._v(" "),s("p",[t._v("因为 Node 代表着线程，所以它提供了几个状态值来代表线程在队列中的状态 ：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Node的状态默认为 0")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此任务已取消")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CANCELLED")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前节点的下一个节点挂起了")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SIGNAL")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前节点在等待队列中")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONDITION")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PROPAGATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("谁拥有这些状态值呢？"),s("strong",[t._v("waitStatus")])]),t._v(" "),s("p",[t._v("线程都是以 Node 形式保存在 AQS 中的，Node中提供了几种状态供线程使用，例如 已取消（1）、默认（0）、挂起（-1）、等待（-2）....")]),t._v(" "),s("p",[t._v("同时，如果你正在看源码，还会看到两个属性 :")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共享模式")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SHARED")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 独占模式")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EXCLUSIVE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("SHARED 和 EXCLUSIVE 两个单词的意思很明显 ：共享和独占。")]),t._v(" "),s("ol",[s("li",[t._v("独占模式即当锁被某个线程成功获取时，其他线程无法获取到该锁，"),s("strong",[t._v("同一时间只有一个线程能拿到锁执行")]),t._v("，锁的状态只有0和1两种情况。例如 ReentrantLock，一次只有一个线程可以工作。")]),t._v(" "),s("li",[t._v("共享模式即当锁被某个线程成功获取时，其他线程仍然可能获取到该锁，"),s("strong",[t._v("同一时间有多个线程可以拿到锁协同工作")]),t._v("，锁的状态大于或等于0。例如 CountDownLatch，一次可以有多个线程工作。")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-同步队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-同步队列"}},[t._v("#")]),t._v(" 2.2 同步队列")]),t._v(" "),s("p",[t._v("这个同步队列是由双向链表实现的。从上面所说的可以知道，AQS中的同步队列是由Node组成、Node中的prev和next连接。")]),t._v(" "),s("p",[t._v("只有节点肯定不行，AQS中有两个属性控制这个双向链表，head 和 tail 。即头和尾。头是一个虚拟节点，它里面的 thread变量 一直是NULL并不会代表哪个线程；尾是有具体意义的，会代表某一个线程。即：头节点无意义，其他节点都代表一个线程。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726171337940.png",alt:"同步队列"}})]),t._v(" "),s("p",[t._v("注意喽，同步队列的头节点是无意义的，线程封装的节点不能成为头节点，只能成为头节点后的节点。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-等待队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-等待队列"}},[t._v("#")]),t._v(" 2.3 等待队列")]),t._v(" "),s("p",[t._v("Node组成等待队列，Node中的"),s("code",[t._v("nextWaiter")]),t._v("连接成为等待队列。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726172213584.png",alt:"image-20230726172213584"}})]),t._v(" "),s("p",[t._v("奇怪的是，当我在AQS中寻找与管理同步队列的head和tail类似的属性时并没有找到，但我还是找到了管理等待队列的属性："),s("code",[t._v("firstWaiter")]),t._v("、"),s("code",[t._v("lastWaiter")])]),t._v(" "),s("p",[t._v("它在AQS另一个内部类中 ："),s("code",[t._v("ConditionObject")]),t._v("。")]),t._v(" "),s("p",[t._v("说来也是，就 “等待队列” 这个词而言，"),s("code",[t._v("等待")]),t._v("肯定是它的一大特点。那么如何实现等待？一个是Object类中的wait方法，另一个就是 Condition 的 await 方法。那么就好解释了：")]),t._v(" "),s("blockquote",[s("p",[t._v("ConditionObject 提供了让 Node 等待的方法，例如 await、signal...通过 Node.nextWaiter 将线程串为一个等待队列，并且使用 firstWaiter 和 lastWaiter 控制/管理 等待队列。")])]),t._v(" "),s("p",[t._v("注意喽，等待队列的 firstWaiter 可不是无意义的哦，线程封装为 Node 后可以成为 firstWaiter")]),t._v(" "),s("h3",{attrs:{id:"_2-4-state状态值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-state状态值"}},[t._v("#")]),t._v(" 2.4 state状态值")]),t._v(" "),s("p",[t._v("这是一个非常重要的属性。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("毕竟AQS提供的是并发支持，有并发就要有锁，那么一个线程怎样才算拿到锁呢？")]),t._v(" "),s("p",[t._v("state 不为 0 的时候证明这个锁被占有了。")]),t._v(" "),s("p",[t._v("同时，由于 AQS 并没有要求实现类必须怎样怎样，所以实现类们也把 state 用的花里胡哨，例如：")]),t._v(" "),s("ol",[s("li",[t._v("在 ReentrantLock 中，state 为 0 代表锁还未被占有，如果为 1 代表被占有，如果大于 1 代表重入。")]),t._v(" "),s("li",[t._v("在 CountDownLatch 中，state 代表着任务数量。")]),t._v(" "),s("li",[t._v("在 ReentrantReadWriteLock 中，将 state 的 32 个字节均分为两部分，一部分表示读锁，一部表示写锁。")])]),t._v(" "),s("h3",{attrs:{id:"_2-5-小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-小结"}},[t._v("#")]),t._v(" 2.5 小结")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("AQS有两个重要的属性：Node和state。")])]),t._v(" "),s("li",[s("p",[t._v("state 是状态值，一般来说代表锁是否被持有，不过具体含义要看实现类如何操作。")])]),t._v(" "),s("li",[s("p",[t._v("共享和独占 ：共享是允许多个线程共同执行任务，独占是同一时间只允许一个线程执行")])]),t._v(" "),s("li",[s("p",[t._v("Node：是线程的代表，线程会被封装为Node在AQS中存在。")]),t._v(" "),s("p",[t._v("Node中有三个属性：next、prev、nextWaiter。")]),t._v(" "),s("ul",[s("li",[t._v("next和prev连接Node成为"),s("code",[t._v("同步队列")]),t._v("。控制同步队列的属性 head 和 tail 在AQS中。")]),t._v(" "),s("li",[t._v("nextWaiter连接Node成为"),s("code",[t._v("等待队列")]),t._v("。控制等待队列的属性 firstWaiter 和 lastWaiter 在 ConditionObject 中（AQS的内部类）")]),t._v(" "),s("li",[t._v("（至于同步队列和等待队列到底有什么用，我想在后续慢慢展开。）")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726212426652.png",alt:"image-20230726212426652"}})]),t._v(" "),s("h2",{attrs:{id:"_3-线程加锁失败后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程加锁失败后"}},[t._v("#")]),t._v(" 3. 线程加锁失败后")]),t._v(" "),s("p",[t._v("在上面说过，AQS 自身并不提供加锁功能，而是实现了加锁失败后的逻辑。这么做有什么好处呢？")]),t._v(" "),s("p",[t._v("程序员可以根据需要进行加锁，比如以下各种锁实现时，想要加锁要满足什么条件：")]),t._v(" "),s("ol",[s("li",[t._v("不可重入锁 ：锁不被任何线程持有时才能加锁成功")]),t._v(" "),s("li",[t._v("可重入锁 ：锁不被任何线程持有，但是如果是自己持有，还可以加锁")]),t._v(" "),s("li",[t._v("公平锁 ：线程抢锁之前先看看有没有其他线程正在等待，没有再抢锁，有就跟在他们后面")]),t._v(" "),s("li",[t._v("非公平锁 ：管它呢直接抢，抢不到再说")]),t._v(" "),s("li",[t._v("读写锁 ：读锁可共享，写锁需排斥。")])]),t._v(" "),s("p",[t._v("如果没有 AQS，这些锁在实现的时候都要写一遍 “线程抢锁失败后需要阻塞等待” 的逻辑，代码太冗余了！AQS 大手一挥，我帮你们实现，程序员只要根据现在的情况判断是否抢锁成功就行了，抢锁失败的线程交给我。")]),t._v(" "),s("p",[t._v("那么现在就来看看 AQS 如何对待抢锁失败的线程的吧。")]),t._v(" "),s("p",[t._v("AQS 需要它的子类实现的方法是 ：tryAcquire()，也就是尝试获取锁，如果获取成功了就没 AQS 要干的事了，但是如果失败，那么就要处理当前线程了：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// tryAcquire让子类去实现")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果获取锁失败，执行后面的逻辑")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将当前线程加入到同步队列中，并且将线程阻塞")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EXCLUSIVE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞停止后，调用该线程的 interrupt方法")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("tryAcquire 方法由子类实现，那么现在来看看 addWaiter 与 acquireQueued 这两个方法")]),t._v(" "),s("ol",[s("li",[t._v("addWaiter ：将当前线程封装为 Node 并放入同步队列")]),t._v(" "),s("li",[t._v("acquireQueued ：")])]),t._v(" "),s("h3",{attrs:{id:"_3-1-将当前线程加入同步队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-将当前线程加入同步队列"}},[t._v("#")]),t._v(" 3.1 将当前线程加入同步队列")]),t._v(" "),s("p",[t._v("步骤分为两大步：构建一个 Node、放到队列尾部。")]),t._v(" "),s("p",[t._v("你想把一个 Node 放到双向链表的尾部，大抵是这三步：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("pre "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nnode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail\n")])])]),s("p",[t._v("也就是将链表尾节点的 next 指针指向自己，自己的 pre 指针指向尾节点，最后自己变成了尾节点。")]),t._v(" "),s("p",[t._v("但是放入队列尾部这个动作说得轻巧，问题就出在这里，当多个 Node 想要挂在同一个尾节点上时，会出现并发情况。但是我懒得画图了😜")]),t._v(" "),s("p",[t._v("AQS 解决并发情况是这样做的 ：先将 node.pre = tail，再使用 CAS 将 node 成为尾节点，最后将 node.pre.next = node，如果 CAS 失败，说明现在出现并发情况了，别的线程抢先一步将 Node 变成了尾节点，此线程的 node 只能挂在那个 node 后面了。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用来源 : addWaiter(Node.EXCLUSIVE)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 Node.EXCLUSIVE 作为 mode 的入参，mode为空。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将此线程封装为独占模式的 Node")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取阻塞队列的尾节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" pred "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果尾节点不为空，把此节点挂在尾节点后面")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 首先执行 node.pre = pred")]),t._v("\n        node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 然后使用CAS的方式将node设置为尾节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果设置成功，就可以将之前尾节点的next指向现在的尾节点: pred.next = node")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetTail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般情况下会在这里return")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果前面没有return，说明什么？")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 说明CAS失败了，也就是出现了并发设置尾节点的情况，即: 多个线程设置尾节点，这个线程设置失败了。")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 虽然失败了，那这个节点可以挂在新来的尾节点上啊~ ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以这个方法的逻辑就是将此节点挂在新来的尾节点上，就不再详细解释了")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("enq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用 CAS 将尾节点的值从 expect 换成 update")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetTail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" expect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" update"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapObject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tailOffset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" update"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_3-2-将当前线程阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-将当前线程阻塞"}},[t._v("#")]),t._v(" 3.2 将当前线程阻塞")]),t._v(" "),s("p",[t._v("此时，node 已经成为同步队列中的尾节点了，但是线程还没有阻塞，AQS 要做的就是让抢锁失败的线程阻塞，所以这个方法至关重要。")]),t._v(" "),s("p",[t._v("一上来就是死循环，当前节点虽然是尾节点，但是如果它的 pre 是头节点代表啥？代表同步队列中只有它一个线程，那我就得重新抢一下锁了，如果抢失败了我再阻塞。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" failed "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" interrupted "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 拿到当前节点的前一个节点，")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果是head节点，可以尝试抢一下锁")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("predecessor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前节点的前一个节点是head节点，尝试抢锁")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" head "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果抢锁成功，将此节点变成head傀儡节点")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// setHead() 方法首先会将 Node内部的线程置为空，为啥置为空？")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 都抢到锁了，这个线程肯定不需要存在于AQS中了。")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 之前的head节点置为空，方便GC")]),t._v("\n                p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n                failed "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" interrupted"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此节点的上一个节点不是头节点，或者抢锁失败，将当前线程 park 起来")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查一下节点的状态，如果已取消就没必要阻塞等待")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldParkAfterFailedAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个方法将当前线程park起来")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parkAndCheckInterrupt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n               "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                interrupted "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("failed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cancelAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将node内部的线程置为空，变成无意义的 head 节点")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    head "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将当前线程park起来")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parkAndCheckInterrupt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ★ 线程阻塞在此处等待唤醒 ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("park")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回对应线程的中断标志位，并且将中断标志位重置变为false")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("interrupted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("注意 ：当锁被释放时，只会唤醒同步队列中第一个节点，也就是 head.next。（这个会在释放锁的逻辑中说）")]),t._v(" "),s("p",[t._v("当阻塞的线程被唤醒，也就代表此节点是 head.next，那么死循环中的 if 条件就可以走通了，于是此节点会使用 tryAcquire 尝试获取锁，如果获取成功就退出循环，如果获取失败就还要阻塞。")]),t._v(" "),s("h2",{attrs:{id:"_4-释放锁后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-释放锁后"}},[t._v("#")]),t._v(" 4. 释放锁后")]),t._v(" "),s("p",[t._v("AQS当然不会管怎么释放锁，释放锁的逻辑让子类去实现，比如不可重入锁直接释放，可重入锁还要判断一下是否重入。")]),t._v(" "),s("p",[t._v("AQS 实现的是之前被阻塞的线程怎么办的逻辑。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("release")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放锁的逻辑让子类实现")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一旦释放成功，AQS就开始唤醒同步队列中的第一个节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 拿到头节点")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 唤醒头节点后面那个节点")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unparkSuccessor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("不出意外的情况下是直接唤醒 head.next 那个线程，但是不出意外的情况下要出意外了 ：")]),t._v(" "),s("p",[t._v("head 后的第一个节点为空！或者说它的状态为取消！那么就从同步队列的尾部向前寻找一个有意义的节点将它唤醒，注意只找一个哦。")]),t._v(" "),s("p",[t._v("并且有一个小细节 ：如果Node的状态为取消，它不会从同步队列中移除，这个细节在 Condition 中会涉及")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此时传入的Node为头节点")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unparkSuccessor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" ws "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetWaitStatus")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 拿到头节点后面的第一个节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般来说不会走这里，而是下面那个if，直接将线程唤醒。")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是走这里的逻辑是因为啥呢？")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// waitStatus在上面有讲解，节点的 waitStatus > 0代表此节点已经取消")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以逻辑就是：如果 head.next 为空或者已经取消，就从同步队列的尾部开始往前寻找，")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 直到找到一个没有取消的节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 直接将这个线程唤醒了")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unpark")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("步骤 ：拿到头节点后的第一个有意义的节点，如果这个节点的状态为取消，说明这个节点刚从等待队列放到同步队列，跳过它从队列的尾部开始找状态正常的，找到之后将它唤醒")]),t._v(" "),s("p",[t._v("所有线程的执行都阻塞在 acquireQueued 方法内部，这个你可以向上翻，我有说。")]),t._v(" "),s("h2",{attrs:{id:"_5-condition"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-condition"}},[t._v("#")]),t._v(" 5. Condition")]),t._v(" "),s("p",[t._v("可能刚说完 AQS 就说 Condition 会有些割裂感，因为很难想象 Condition 与 AQS 有啥关系，对，有关系，还记得 AQS 的 Node 中有一个成员变量 ：nextWaiter")]),t._v(" "),s("p",[t._v("我在之前说过，AQS 本身的逻辑并没有用到这个变量，而是在 ConditionObject 中使用到了，所以 AQS 中第二个队列出现了 ：等待队列")]),t._v(" "),s("div",{staticClass:"custom-block note"},[s("p",{staticClass:"custom-block-title"},[t._v("笔记")]),t._v(" "),s("p",[t._v("请你注意等待队列与同步队列的区别。不要将二者混为一谈")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此Node代表的线程")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于同步队列，此Node的前一个结点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于同步队列，此Node的后一个节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于等待队列，等待队列是一个单向链表组成的队列")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" nextWaiter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点的状态")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" waitStatus"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省略其他变量")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("常用的让线程等待的方法有两种 ：")]),t._v(" "),s("ol",[s("li",[t._v("Object.wait()")]),t._v(" "),s("li",[t._v("Condition.await()")])]),t._v(" "),s("p",[t._v("虽然实现不一样，但是原理是一样的，线程等待的前提肯定是已经拥有锁了，调用 wait 后会释放锁然后阻塞。调用 signal 将线程从等待状态唤醒，进入阻塞状态，可以抢锁。")]),t._v(" "),s("h3",{attrs:{id:"_5-1-condition-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-condition-await"}},[t._v("#")]),t._v(" 5.1 Condition.await()")]),t._v(" "),s("p",[t._v("如果是你，你会如何借助 AQS 来实现 Condition.await() 呢？不就是释放锁之后阻塞嘛~")]),t._v(" "),s("ol",[s("li",[t._v("将此线程封装为 Node 并放入等待队列")]),t._v(" "),s("li",[t._v("调用 AQS 的 release 释放锁")]),t._v(" "),s("li",[t._v("将当前线程阻塞")])]),t._v(" "),s("p",[t._v("对，就是这三步，来看看 AQS 中的 ConditionObject 如何实现这三步的 ：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("await")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("interrupted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将当前线程封装为Node，Node的状态为-2，也就是等待，然后放入等待队列")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这时会将 node.waitStatus 改为 CONDITION")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addConditionWaiter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用 release 方法释放锁")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这时会将 node.waitStatus 改为 CANCELLED ★ 这里特别重要！！！！！")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再次强调，这里会将 node.waitStatus 改为 CANCELLED ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" savedState "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fullyRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" interruptMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 判断 Node 节点的状态")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一次进入时都会返回false，取反后会进入方法将线程阻塞")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isOnSyncQueue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("park")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("interruptMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkInterruptWhileWaiting")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 线程从等待状态恢复后，进入同步队列等待抢锁，这里的逻辑就是上面说过了的。")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" savedState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" interruptMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("THROW_IE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        interruptMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("REINTERRUPT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextWaiter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// clean up if cancelled")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlinkCancelledWaiters")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("interruptMode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("reportInterruptAfterWait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("interruptMode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_5-2-condition-signal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-condition-signal"}},[t._v("#")]),t._v(" 5.2 Condition.signal()")]),t._v(" "),s("p",[t._v("如果是你，你会如何借助 AQS 来实现 Condition.signal() 呢？不就是唤醒锁、把它加入同步队列嘛~")]),t._v(" "),s("p",[t._v("Condition.signal() 会唤醒在等待队列中等待时间最长的节点（首节点）")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 传入的是等待队列的头节点（线程是可以成为头节点的）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSignal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般不会走这里")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("firstWaiter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextWaiter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            lastWaiter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将头节点的next指针置为空")]),t._v("\n        first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextWaiter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("transferForSignal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("\n             "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("first "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" firstWaiter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("transferForSignal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetWaitStatus")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CONDITION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将该节点加入同步队列尾部")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("enq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 刚刚在 await方法中，我特别强调了，fullyRelease 方法会将节点的状态改为取消")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也就是 node.waitStatus = 1, 即 ws = 1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" ws "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetWaitStatus")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ws"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SIGNAL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LockSupport")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unpark")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("思考 ：为啥调用 await() 方法让线程释放锁后，线程 Node 的状态会变成取消（node.waitStatus = 1）呢？")]),t._v(" "),s("p",[t._v("因为 signal 方法的步骤为 ：")]),t._v(" "),s("ol",[s("li",[t._v("将 node 放入同步队列")]),t._v(" "),s("li",[t._v("将线程唤醒")])]),t._v(" "),s("p",[t._v("将 node 放入同步队列后，万一被唤醒了怎么办？那就要通过一些手段防止这种概率特别小的情况出现，也就是线程调用 await() 进入等待之前先将 Node 的状态变成 取消，那么就不会被误唤醒！真叼啊。")]),t._v(" "),s("p",[t._v("Condition 的 singalAll 方法，相当于对等待队列的每个节点均执行一次 singal 方法，效果就是将等待队列中所有节点全部移动到同步队列，并唤醒每个节点的线程。")]),t._v(" "),s("h2",{attrs:{id:"_5-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[t._v("#")]),t._v(" 5. 总结")]),t._v(" "),s("p",[t._v("至此，AQS 的核心功能已经说完了，没有讲加锁、释放锁？因为加锁、释放锁的逻辑本来就不是 AQS 要完成的呀。")]),t._v(" "),s("p",[t._v("所以加锁与释放锁我会在 ReentrantLock、CountDownLatch、ReadWriteLock 中讲。")])])}),[],!1,null,null,null);s.default=e.exports}}]);