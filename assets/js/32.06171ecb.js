(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{358:function(t,s,a){"use strict";a.r(s);var n=a(7),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_0-简述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0-简述"}},[t._v("#")]),t._v(" 0. 简述")]),t._v(" "),s("p",[t._v("零拷贝这个东西实际上我不想放在 Java基础 这部分说，因为严格来说它设计的操作系统知识比较多，但是也不想思考这么多了~")]),t._v(" "),s("p",[t._v("如果你还没有相关的操作系统知识，这篇文章不建议看哦~")]),t._v(" "),s("p",[t._v("或者可以先看一下前置的操作系统知识：\n"),s("RouterLink",{attrs:{to:"/02.文章/60.操作系统/10.用户态和内核态.html"}},[t._v("用户态和内核态")]),t._v("  （包含用户态内核态、系统调用的知识）")],1),t._v(" "),s("p",[t._v("零拷贝这个技术这个很多中间件都有用过，例如RocketMQ、netty。")]),t._v(" "),s("p",[t._v("并且由于技术是"),s("strong",[t._v("拷贝")]),t._v("，所以下文所有的用户态、内核态之间的切换都基于 文件。")]),t._v(" "),s("h2",{attrs:{id:"_1-dma"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-dma"}},[t._v("#")]),t._v(" 1. DMA")]),t._v(" "),s("p",[t._v("在很久之前，用户态与内核态切换后的 数据读取操作 是完全由CPU负责的。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802012824.png",alt:"CPU负责读写数据"}})]),t._v(" "),s("p",[t._v("这个过程中CPU是阻塞的，如果只读几个字符也就算了，但是如果要读几个G的文件，那CPU就有的受了。")]),t._v(" "),s("p",[t._v("所以就发明了 "),s("font",{attrs:{color:"Green"}},[s("strong",[t._v("DMA 技术")])])],1),t._v(" "),s("p",[t._v("DMA ："),s("code",[t._v("Direct Memory Access")]),t._v("，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。如图。")]),t._v(" "),s("p",[t._v("但是 CPU 在这个过程中也是必不可少的，因为"),s("code",[t._v("要读哪个文件")]),t._v("、"),s("code",[t._v("读多少")]),t._v("这些基本信息都需要CPU去告诉DMA。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802012858.png",alt:"DMA负责读写数据"}})]),t._v(" "),s("h2",{attrs:{id:"_2-传输文件时发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-传输文件时发生了什么"}},[t._v("#")]),t._v(" 2. 传输文件时发生了什么")]),t._v(" "),s("p",[t._v("在进行文件传输时一般会涉及两个系统调用 ：read、write")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tmp_buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("socket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" tmp_buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("一个 read() 可以发起系统调用，使进程从用户态切换为内核态，数据准备好后又从 内核态切换回 用户态。即："),s("font",{attrs:{color:"Green"}},[t._v("一次系统调用会发生两次上下文切换。")]),t._v("（一次write同理）")],1),t._v(" "),s("p",[t._v("文件传输虽然只有两行代码，但却做了不少事情：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802012920.png",alt:""}})]),t._v(" "),s("p",[t._v("一共 2 次系统调用，也就是 4 次用户态与内核态 上下文的切换。上下文切换的成本很高，一次切换需要几十纳秒到几微秒。其次还发生了 4 次数据拷贝（2次DMA拷贝 + 2次CPU拷贝）")]),t._v(" "),s("p",[t._v("这四次拷贝：")]),t._v(" "),s("ol",[s("li",[t._v("第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。")]),t._v(" "),s("li",[t._v("第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。")]),t._v(" "),s("li",[t._v("第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。")]),t._v(" "),s("li",[t._v("第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。")])]),t._v(" "),s("p",[t._v("这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。")]),t._v(" "),s("p",[t._v("所以，要想提高文件传输的性能，就"),s("code",[t._v("需要减少「用户态与内核态的上下文切换」和「数据拷贝」的次数。")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("减少用户态和内核态的上下文切换就是 减少系统调用的次数")])]),t._v(" "),s("li",[s("p",[t._v("减少数据拷贝次数 ："),s("code",[t._v("「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。")]),t._v("因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此用户的缓冲区是没有必要存在的。我们可以直接将数据从内核缓冲区拷贝到socket缓冲区")])])]),t._v(" "),s("p",[t._v("现在就要正式介绍零拷贝了，零拷贝也正是实现上述提高性能的实现方法。")]),t._v(" "),s("h2",{attrs:{id:"_3-零拷贝的实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-零拷贝的实现方式"}},[t._v("#")]),t._v(" 3. 零拷贝的实现方式")]),t._v(" "),s("p",[t._v("零拷贝的实现通常有两种 ：")]),t._v(" "),s("blockquote",[s("ol",[s("li",[s("p",[t._v("mmap "),s("strong",[t._v("+")]),t._v(" write")])]),t._v(" "),s("li",[s("p",[t._v("sendfile")])])])]),t._v(" "),s("h3",{attrs:{id:"_3-1-mmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-mmap"}},[t._v("#")]),t._v(" 3.1 mmap")]),t._v(" "),s("p",[t._v("首先介绍一下大名鼎鼎的 mmap + write。")]),t._v(" "),s("p",[t._v("之前说过，减少数据拷贝次数主要是减少 “从内核态缓冲区拷贝到用户态缓冲区”这一步，想要把它删掉。")]),t._v(" "),s("p",[t._v("现在使用 mmap 替代 read 进行读操作")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("buf "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mmap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sockfd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" buf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("mmap() 系统调用函数会"),s("font",{attrs:{color:"Green"}},[s("strong",[t._v("直接把内核缓冲区里的数据「映射」(不是拷贝) 到用户空间")])]),t._v("，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。也可以说用户态和内核态现在共享缓冲区了。")],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802013008.png",alt:""}})]),t._v(" "),s("p",[t._v("虽然可以减少一次 数据拷贝，可这仍旧不是理想的零拷贝，我们最终的目的是："),s("strong",[t._v("减少系统调用带来的上下文切换。")])]),t._v(" "),s("h3",{attrs:{id:"_3-2-sendfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-sendfile"}},[t._v("#")]),t._v(" 3.2 sendfile")]),t._v(" "),s("p",[t._v("再来介绍一下sendfile")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ssize_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sendfile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" out_fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" in_fd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("off_t")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("offset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这个sendfile函数是Linux用于专门发送文件的函数，目的就是替代 read + write。")]),t._v(" "),s("p",[t._v("它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。\n其次，该系统调用可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态。"),s("font",{attrs:{color:"Green"}},[t._v("这样就只剩下 2 次上下文切换，和 3 次数据拷贝。")]),t._v("\n如下图：")],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802013029.png",alt:""}})]),t._v(" "),s("p",[t._v("当然，这还不是完美的零拷贝技术，如果网卡支持 scatter-gather 特性，那么sendfile可以不需要第二部的CPU拷贝和第三步的DMA拷贝，"),s("font",{attrs:{color:"Green"}},[s("strong",[t._v("直接将数据从内核缓冲区发送到网卡")])]),t._v("。\n这被称为 "),s("font",{attrs:{color:"Green"}},[s("strong",[t._v("SG-DMA拷贝")]),t._v("。")])],1),t._v(" "),s("p",[s("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802013045.png",alt:""}})]),t._v(" "),s("p",[t._v("那么优化到现在，"),s("strong",[t._v("减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。")])]),t._v(" "),s("p",[t._v("所以，总体来看，"),s("strong",[t._v("零拷贝技术可以把文件传输的性能提高至少一倍以上")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("而在Java中，MappedByteBuffer就调用了mmap，transferTo/transferFrom就是sendfile方法。")])]),t._v(" "),s("p",[t._v("如果涉及到文件传输，transferTo是首选，但是如果涉及到对内存数据的修改选用MappedByteBuffer。")])])}),[],!1,null,null,null);s.default=e.exports}}]);