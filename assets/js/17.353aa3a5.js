(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{340:function(v,_,s){"use strict";s.r(_);var a=s(7),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"redis-持久化机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[v._v("#")]),v._v(" Redis 持久化机制")]),v._v(" "),_("h2",{attrs:{id:"_1-概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-概述"}},[v._v("#")]),v._v(" 1. 概述")]),v._v(" "),_("p",[_("code",[v._v("Redis")]),v._v(" ​为了保证性能，会将所有数据放在内存中，那么万一 Redis 宕机，数据岂不是全部丢失了？")]),v._v(" "),_("p",[v._v("不要怕，Redis 自然想到了这一点，它提供了三种持久化机制将内存中的数据持久化到磁盘中。")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("RDB")])]),v._v(" "),_("p",[v._v("快照方式持久化（snapshot），快照在 Linux 就已经学过，保存所有数据的状态，下次开机直接按照这个状态恢复。")]),v._v(" "),_("p",[v._v("因为保存的快照是以.rdb 结尾的文件，故称此方式为 RDB 持久化方式。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("AOF")])]),v._v(" "),_("p",[v._v("（append only file）只追加日志文件，记录 Redis 所有写命令，下次开机将这些命令全部执行，即可恢复数据。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("混合型持久化")])]),v._v(" "),_("p",[v._v("RDB 虽然快，但是数据丢失问题较为严重；AOF 虽然能保证数据安全，但是执行所有命令需要很长时间。")]),v._v(" "),_("p",[v._v("所以 Redis4.x 以后，将两种方式结合，RDB 文件的内容放在 AOF 文件中，以.aof 文件的形式存储。在恢复数据时，先加载 rdb 的内容，再执行 aof 的内容。缺点是两种格式混合在一起难以阅读。")])])]),v._v(" "),_("p",[v._v("==需要注意的是，不论是哪种方式，都无法保证数据的绝对安全。==")]),v._v(" "),_("h2",{attrs:{id:"_2-rdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-rdb"}},[v._v("#")]),v._v(" 2. RDB")]),v._v(" "),_("p",[v._v("snapshot 想必大家已经不陌生了，Linux 已经接触过这个机制：==保存现在的状态，随时准备恢复。==")]),v._v(" "),_("p",[v._v("拍摄的快照以**.rdb** 的形式保存在磁盘中。")]),v._v(" "),_("p",[v._v("假如在 Redis 宕机之前拍摄的快照为：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102101206-yrbh2d0.png",alt:"image"}})]),v._v(" "),_("p",[v._v("那么下次开机就可以即将这两个数据恢复。")]),v._v(" "),_("p",[v._v("Redis 提供了两种拍摄快照的方式 ：自动、手动。其中手动拍摄快照有两个命令：save、bgsave")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102101717-g9cnz1r.png",alt:"image"}})]),v._v(" "),_("h3",{attrs:{id:"_2-1-手动快照"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-手动快照"}},[v._v("#")]),v._v(" 2.1 手动快照")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("save")])]),v._v(" "),_("p",[v._v("由主进程完成快照的拍摄，持久化过程中其他命令阻塞。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102105300-zs34lcz.png",alt:"image"}})])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("bgsave")])]),v._v(" "),_("p",[v._v("background save，主线程 fork 出一个子进程，由这个子进程完成持久化。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102105321-usbmqdu.png",alt:"image"}})])])]),v._v(" "),_("blockquote",[_("p",[v._v("fork ：")]),v._v(" "),_("p",[v._v("当一个进程创建子进程时，底层的操作系统会创建该进程的副本，在类 unix 系统中创建子进程的操作会进行优化：在刚开始的时候，父子进程共享相同内存，直到父进程/子进程对内存进行写操作后结束共享，各用各的。")])]),v._v(" "),_("h3",{attrs:{id:"_2-2-自动快照"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-自动快照"}},[v._v("#")]),v._v(" 2.2 自动快照")]),v._v(" "),_("p",[v._v("在 redis.conf 配置文件中存在，参数如下:（版本不同，默认参数不同）")]),v._v(" "),_("div",{staticClass:"language-vim extra-class"},[_("pre",{pre:!0,attrs:{class:"language-vim"}},[_("code",[v._v("#   "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" After "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("3600")]),v._v(" seconds "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("an hour"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),v._v(" at least "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token builtin"}},[v._v("key")]),v._v(" changed\n#   "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" After "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("300")]),v._v(" seconds "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("5")]),v._v(" minutes"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),v._v(" at least "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("100")]),v._v(" keys changed\n#   "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" After "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("60")]),v._v(" seconds "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),v._v(" at least "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("10000")]),v._v(" keys changed\n\n# save "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("3600")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n# save "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("300")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("100")]),v._v("\n# save "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("60")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("10000")]),v._v("\n")])])]),_("p",[v._v("解释 ：")]),v._v(" "),_("p",[v._v("1h 内有一个键被改变会触发快照拍摄。")]),v._v(" "),_("p",[v._v("5mins 内有 100 个键被改变会触发快照拍摄。")]),v._v(" "),_("p",[v._v("1min 内有 10000 个键被改变会触发快照拍摄。")]),v._v(" "),_("p",[v._v("这些快照的拍摄方式都是 bgsave。")]),v._v(" "),_("p",[_("strong",[v._v("优点 ：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("rdb 文件的加载速度特别快，远超 aof。")])]),v._v(" "),_("li",[_("p",[v._v("使用单独子进程来进行持久化，主进程不会进行任何 IO 操作。")])])]),v._v(" "),_("p",[_("strong",[v._v("缺点 ：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("容易造成数据丢失。")])]),v._v(" "),_("li",[_("p",[v._v("每次拍快照都要创建子进程，浪费资源.。")])])]),v._v(" "),_("h2",{attrs:{id:"_3-aof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof"}},[v._v("#")]),v._v(" 3. AOF")]),v._v(" "),_("p",[v._v("这种机制可以将所有客户端执行的写命令记录到日志文件中，"),_("code",[v._v("AOF")]),v._v(" ​持久化会将被执行的写命令写到 AOF 文件末尾，以此来记录数据发生变化的全过程，因此只要 Redis 从头到尾执行一遍 AOF 文件中的命令，就可以恢复之前的数据。")]),v._v(" "),_("h3",{attrs:{id:"_3-1-aof-机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-aof-机制"}},[v._v("#")]),v._v(" 3.1 AOF 机制")]),v._v(" "),_("p",[_("code",[v._v("RDB")]),v._v(" ​是间隔一段时间进行持久化，如果持久化之间的时间内发生故障，会出现数据丢失。而 "),_("code",[v._v("AOF")]),v._v(" ​持久化方式能很好的解决 "),_("code",[v._v("RDB")]),v._v(" ​持久化方式造成的数据丢失，"),_("code",[v._v("AOF")]),v._v(" ​持久化到硬盘中的并不是内存中的数据快照，而是"),_("strong",[v._v("将所有写命令记录到日志中")]),v._v("。")]),v._v(" "),_("p",[v._v("AOF 能做到最多丢失 1s 内的数据，甚至不丢失数据。")]),v._v(" "),_("p",[v._v("Redis 提供了三种 AOF 策略 ：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("appendfsync always")])]),v._v(" "),_("p",[v._v("每执行一次写命令，都对 aof 文件续写。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("appendfsync everysec")]),v._v("​")]),v._v(" "),_("p",[v._v("每一秒进行一次 aof 文件续写，这一秒的写命令都会记录。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("appendfsync no")])]),v._v(" "),_("p",[v._v("并不是不开启，而是将 aof 续写的时机交给操作系统管理，操作系统开心了就续写，不开心就不续写。")])])]),v._v(" "),_("p",[v._v("这三种策略其实也就是控制aof缓存写入日志的时机罢了，什么？aof缓存是什么呢？往下看")]),v._v(" "),_("p",[v._v("AOF文件记录的具体过程 ：先将命令写入内存，再将命令写入日志。")]),v._v(" "),_("ol",[_("li",[v._v("命令追加 ：将新执行的命令追加到 aof缓存 中")]),v._v(" "),_("li",[v._v("文件写入 ：将 aof缓存 中的数据写到aof文件中\n这一步需要进行系统调用，看过操作系统的都知道，系统调用需要触发函数，比如read、write，redis用的是 "),_("font",{attrs:{color:"Blue"}},[v._v("fsync()")]),v._v(", 这个命令怎么触发？\n就是上面配置的AOF策略，always、everysec、no。")],1)]),v._v(" "),_("p",[v._v("所以说，AOF的三种策略其实就是控制执行 fsync命令 的时机。")]),v._v(" "),_("p",[_("strong",[v._v("优点 ：")])]),v._v(" "),_("ul",[_("li",[v._v("保证数据丢失风险降到最低")])]),v._v(" "),_("p",[_("strong",[v._v("缺点 ：")])]),v._v(" "),_("ul",[_("li",[v._v("aof 文件的体积会很大，同时加载速度很慢")])]),v._v(" "),_("h3",{attrs:{id:"_3-2-aof-文件的重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-aof-文件的重写"}},[v._v("#")]),v._v(" 3.2 AOF 文件的重写")]),v._v(" "),_("p",[v._v("随着 "),_("code",[v._v("Redis")]),v._v(" ​在线上运行的时间越来越久，客户端执行的命令越来越多，"),_("code",[v._v("AOF")]),v._v(" ​的文件也会越来越大。")]),v._v(" "),_("p",[v._v("当我们执行 100 次 "),_("code",[v._v("set name 张三")]),v._v("​，其中 99 次都是多余的，因为想要恢复只要执行一次 "),_("code",[v._v("set name 张三")]),v._v(" ​就行了。为了压缩 AOF 文件的体积，Redis 提供了 "),_("code",[v._v("AOF文件重写机制")]),v._v("​。")]),v._v(" "),_("p",[v._v("有两种方式触发 AOF 的重写机制：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("手动：执行 "),_("code",[v._v("bgrewrite")]),v._v("​，background rewrite，不会阻塞 Redis")])]),v._v(" "),_("li",[_("p",[v._v("自动：在配置文件中进行配置")]),v._v(" "),_("div",{staticClass:"language-vim extra-class"},[_("pre",{pre:!0,attrs:{class:"language-vim"}},[_("code",[v._v("auto"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("aof"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("rewrite"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("percentage "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("100")]),v._v("\nauto"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("aof"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("rewrite"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("min"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("-")]),v._v("size 64mb\n")])])]),_("p",[v._v("当 AOF 文件体积大于 64MB，或者比上一次重写之后体积大了 100%，会自动触发。")]),v._v(" "),_("p",[v._v("如果重写过于频繁，可以考虑将 auto-aof-rewrite-percentage 设置为更大。")])])]),v._v(" "),_("p",[v._v("‍")]),v._v(" "),_("blockquote",[_("p",[v._v("AOF 重写机制并没有根据现有的AOF文件重写，而是是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。")])]),v._v(" "),_("p",[v._v("为什么不使用原有的 AOF 文件呢?")]),v._v(" "),_("p",[v._v("如果在原有的AOF文件基础上重新，但凡AOF文件重写过程中宕机或者失败，原有的AOF文件就被污染了，可能无法用于数据恢复。所以保留原有的AOF文件是保底策略。")]),v._v(" "),_("div",{staticClass:"custom-block note"},[_("p",{staticClass:"custom-block-title"},[v._v("重写的具体过程")]),v._v(" "),_("p",[v._v("重写使用到了写时复制")]),v._v(" "),_("p",[v._v("写时复制 ：父进程 fork 出一个子进程，两个进程共用同一块内存区域（二者的虚拟内存虽然不相同，但是虚拟内存对应的物理内存是一样的），主进程是可以正常处理读请求的，但是如果出现写请求，且操作的数据是已经存在的，⭐操作系统就会将"),_("strong",[v._v("这个数据在父进程的物理内存")]),v._v("复制一份交给子进程。注意，这里复制的物理内存是 修改了哪个数据就只复制这个数据的物理内存，而不是将父进程的所有物理内存都复制一份。")]),v._v(" "),_("p",[v._v("Redis 设置了一个 "),_("strong",[v._v("AOF 重写缓冲区")]),v._v("。 在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」。")]),v._v(" "),_("p",[v._v("当子进程完成AOF的重写后，会通知父进程，父进程操作"),_("strong",[v._v("AOF 重写缓冲区")]),v._v("，将追加的数据写入AOF文件（这个步骤是父进程进行的）")])]),v._v(" "),_("p",[v._v("需要注意的是 ：RDB快照和AOF重写的过程都用到了写时复制。")]),v._v(" "),_("h2",{attrs:{id:"_4-混合型持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-混合型持久化"}},[v._v("#")]),v._v(" 4. 混合型持久化")]),v._v(" "),_("p",[v._v("因为 "),_("code",[v._v("RDB")]),v._v(" ​虽然加载快但是存在数据丢失，"),_("code",[v._v("AOF")]),v._v(" ​数据安全但是加载缓慢，"),_("code",[v._v("Redis")]),v._v(" ​为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 "),_("code",[v._v("RDB")]),v._v(" ​文件的内容和增量的 "),_("code",[v._v("AOF")]),v._v(" ​日志文件存在一起。这里的 "),_("code",[v._v("AOF")]),v._v(" ​日志不再是全量 的日志，而是自持久化开始到持久化结束的这段时间发生的增量 "),_("code",[v._v("AOF")]),v._v(" ​日志，通常这部分 "),_("code",[v._v("AOF")]),v._v(" ​日志很小。"),_("code",[v._v("Redis")]),v._v(" ​重启的时候，可以先加载 "),_("code",[v._v("RDB")]),v._v(" ​的内容，然后再重放增量 "),_("code",[v._v("AOF")]),v._v(" ​日志，就可以完全替代之前的 "),_("code",[v._v("AOF")]),v._v(" ​全量文件重放，恢复效率因此大幅得到提升（混合型持久化最终生成的文件后缀是 "),_("code",[v._v(".aof")]),v._v("​，可以通过 "),_("code",[v._v("redis.conf")]),v._v(" ​文件中 "),_("code",[v._v("aof-use-rdb-preamble yes")]),v._v(" ​配置开启）。")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("优点：")])]),v._v(" "),_("p",[v._v("结合了 "),_("code",[v._v("RDB")]),v._v(" ​和 "),_("code",[v._v("AOF")]),v._v(" ​的优点，使得数据恢复的效率大幅提升")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("缺点：")])]),v._v(" "),_("p",[v._v("兼容性不好，"),_("code",[v._v("Redis-4.x")]),v._v(" ​新增，虽然最终的文件也是 "),_("code",[v._v(".aof")]),v._v(" ​格式的文件，但在 "),_("code",[v._v("4.0")]),v._v(" ​之前版本都不识别该 "),_("code",[v._v("aof")]),v._v(" ​文件，同时由于前部分是 "),_("code",[v._v("RDB")]),v._v(" ​格式，阅读性较差。")])])]),v._v(" "),_("h2",{attrs:{id:"_5-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[v._v("#")]),v._v(" 5. 总结")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102132247-ww8ti4d.png",alt:"image"}})])])}),[],!1,null,null,null);_.default=e.exports}}]);