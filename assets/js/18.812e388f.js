(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{345:function(t,v,_){"use strict";_.r(v);var e=_(7),s=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"redis内存回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis内存回收"}},[t._v("#")]),t._v(" Redis内存回收")]),t._v(" "),v("h2",{attrs:{id:"_1-过期回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-过期回收"}},[t._v("#")]),t._v(" 1. 过期回收")]),t._v(" "),v("p",[t._v("Redis支持设置数据有效时间，有效期过了数据就删除掉，那么Redis肯定要增加字段记录数据的有效期，如何增加字段呢？数据到期立马删除吗？")]),t._v(" "),v("p",[t._v("接下来看看Redis采用的过期回收策略：")]),t._v(" "),v("p",[t._v("Redis本身是一个键值型的数据库，因此所有的数据都保存在Dict中，不过在其database结构体中有两个Dict，一个存储所有数据，一个存储有ttl的数据。")]),t._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("redisdb")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    dict "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dict"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    dict "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("expires"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("ul",[v("li",[v("code",[t._v("dict")]),t._v(" ：以key-value形式存储所有数据")]),t._v(" "),v("li",[v("code",[t._v("expires")]),t._v(" ：以key-ttl形式存储带有过期时间的数据。")])]),t._v(" "),v("p",[t._v("想知道一个key是否过期，拿着key去第二个Dict查就行了。")]),t._v(" "),v("p",[t._v("那么数据到期立即删除吗？")]),t._v(" "),v("p",[t._v("不同的key带有不同的过期时间，如果给每一个key都设置定时任务，太浪费资源。")]),t._v(" "),v("p",[t._v("Redis采用两种删除机制：")]),t._v(" "),v("ol",[v("li",[t._v("惰性删除 ：每次访问时判断是否过期，过期则删除。")]),t._v(" "),v("li",[t._v("周期删除 ：通过定时任务周期性的抽部分过期key删除。")])]),t._v(" "),v("p",[t._v("惰性删除的优点和缺点都很明显，它不必开启额外的任务，只需要在访问时判断。但是过期数据一直不访问呢？就会遗留在内存。")]),t._v(" "),v("p",[t._v("周期删除又有两种方式：")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("SLOW")]),t._v(" ：Redis设置一个定时任务serverCron()，按照1秒10次的频率执行过期Key清理。")]),t._v(" "),v("li",[v("code",[t._v("FAST")]),t._v(" ：Redis的每个事件循环前会调用beforeSleep()，执行过期Key清理。")])]),t._v(" "),v("p",[t._v("这两种策略感觉就像迷你版的FullGC和MinorGC。")]),t._v(" "),v("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230129144609629.png",alt:"image-20230129144609629"}}),t._v(" "),v("blockquote",[v("p",[t._v("Q ：Redis如何知道哪些key过期了？")]),t._v(" "),v("p",[t._v("A ：使用两个Dict，一个存放key-value，一个存放key-ttl")])]),t._v(" "),v("blockquote",[v("p",[t._v("Q ：数据过期立马删除吗？")]),t._v(" "),v("p",[t._v("A ：有惰性删除和周期删除两种策略，周期删除有两种方式：FAST、SLOW。")])]),t._v(" "),v("h2",{attrs:{id:"_2-内存淘汰"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存淘汰"}},[t._v("#")]),t._v(" 2. 内存淘汰")]),t._v(" "),v("p",[t._v("内存淘汰 ："),v("strong",[t._v("当Redis内存使用达到设置的阈值时，Redis主动挑选部分key删除来释放更多的内存")]),t._v("。")]),t._v(" "),v("p",[t._v("Redis有八种不同的淘汰策略 ：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("策略")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("noeviction")]),t._v(" "),v("td",[t._v("默认策略，不淘汰任何数据，不允许写入新数据")])]),t._v(" "),v("tr",[v("td",[t._v("volatile-ttl")]),t._v(" "),v("td",[t._v("对设置了ttl的数据比较，淘汰快过期的数据")])]),t._v(" "),v("tr",[v("td",[t._v("allkeys-random")]),t._v(" "),v("td",[t._v("全体数据随即淘汰")])]),t._v(" "),v("tr",[v("td",[t._v("volatile-random")]),t._v(" "),v("td",[t._v("设置了ttl的数据，随即淘汰")])]),t._v(" "),v("tr",[v("td",[t._v("allkeys-lru")]),t._v(" "),v("td",[t._v("全体数据，基于lru算法进行淘汰")])]),t._v(" "),v("tr",[v("td",[t._v("volatile-lru")]),t._v(" "),v("td",[t._v("设置了ttl的数据，基于lru算法进行淘汰")])]),t._v(" "),v("tr",[v("td",[t._v("allkeys-lfu")]),t._v(" "),v("td",[t._v("全体数据，基于lfu算法进行淘汰")])]),t._v(" "),v("tr",[v("td",[t._v("volatile-lfu")]),t._v(" "),v("td",[t._v("设置了ttl的数据，基于lfu算法进行淘汰")])])])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("=="),v("strong",[t._v("LRU")]),t._v("==")]),t._v(" "),v("p",[t._v("Least Recently Used "),v("code",[t._v("最少最近使用")])]),t._v(" "),v("p",[t._v("用当前时间减去最后一次访问时间，这个值越大，淘汰优先级越高。")])]),t._v(" "),v("li",[v("p",[t._v("=="),v("strong",[t._v("LFU")]),t._v("==")]),t._v(" "),v("p",[t._v("Least Frequently Used "),v("code",[t._v("最少频率使用")])]),t._v(" "),v("p",[t._v("统计每一个key的访问频率，频率越小淘汰优先级越高。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);