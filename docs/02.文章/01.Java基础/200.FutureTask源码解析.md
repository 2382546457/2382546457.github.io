---
title: FutureTask源码解析
date: 2023-11-25 21:05:37
permalink: /pages/937dd3/
---
## 1. 简述

FutureTask 实现了 Runnable、Future，可以进行任务的异步执行，但是 FutureTask 会阻塞主线程。

它提供了两个功能 ：

1. 执行任务
2. 阻塞等待任务执行完毕

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    Callable<String> callable = new Callable<String>() {
        @Override
        public String call() throws Exception {
            // 处理业务
            return "执行结束";
        }
    };

    FutureTask<String> futureTask = new FutureTask<>(callable);
    // 执行任务
    futureTask.run();
    // 阻塞等待结果
    futureTask.get();
}
```

从代码中可以猜测 ：

- FutureTask中有一个 Callable 变量
- FutureTask.run() 调用了 callable.run() 去获取结果
- 此时 FutureTask.get() 的结果会是null，故执行 FutureTask.get() 的线程会阻塞，Callable.run() 方法运行。
- Callable.run() 方法结束，将运行的结果交给 FutureTask，FutureTask 停止阻塞。

![image-20231125184326076](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231125184326076.png)

想要搞懂 FutureTask 的源码，必须要搞懂它做了什么，根据上面的阐述可以简单猜测：

1. FutureTask 中的变量不仅有 Callable，还有 Callable 执行后的结果result，Callable执行后将结果设置给result。
2. FutureTask.get() 方法用 while(true) 循环检查result，如果为空说明没执行完，继续阻塞；如果不为空说明已经执行结束，退出阻塞并返回结果。

简单实现一下FutureTask

```java
public class FutureTask<T> {
    // 任务
    private Callable<T> callable;
    // 结果
    private T result;
    
    public void run() {
    	callable.run();    
    }
    
    public T get() {
        while (true) {
            if (result == null) {
                // 当前线程让出执行权，也就是主线程让出执行权。
                Thread.yield();
            } else {
            	return T;    
            }
        }
    }
}
```

但是真正的 FutureTask 才不会这么简单。接下来进入 FutureTask 的源码一探究竟。

## 2. FutureTask 中的状态变量

我们刚才使用 result 结果变量充当了判断任务是否结束的标志，其实 FutureTask 没有用它，而是定义了几个状态变量 ：

```java
// 当前状态
private volatile int state;

// NEW 新建状态，表示这个 FutureTask还没有开始运行
private static final int NEW = 0;
// COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了，但是还有一些后续操作没有完成。
private static final int COMPLETING   = 1;

// FutureTask 任务完结，正常完成，没有发生异常
private static final int NORMAL       = 2;
// FutureTask 任务完结，因为发生异常。
private static final int EXCEPTIONAL  = 3;
// FutureTask 任务完结，因为取消任务
private static final int CANCELLED    = 4;
// FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求
private static final int INTERRUPTING = 5;
// FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求
private static final int INTERRUPTED  = 6;
```

大致可以分为两种 ：已执行、未执行。

如果 state > COMPLETING 就说明任务已经执行完了，不管是正常执行还是异常执行，反正现在要把结果result返回给主线程。

讲到现在，FutureTask 中的变量共有 ：

```java
public class FutureTask<T> {
    // 任务
    private Callable<T> callable;
    // 结果
    private Object outcome;
    // 当前状态
    private volatile int state;

    // NEW 新建状态，表示这个 FutureTask还没有开始运行
    private static final int NEW = 0;
    // COMPLETING 完成状态， 表示 FutureTask 任务已经计算完毕了
    // 但是还有一些后续操作，例如唤醒等待线程操作，还没有完成。
    private static final int COMPLETING   = 1;

    // FutureTask 任务完结，正常完成，没有发生异常
    private static final int NORMAL       = 2;
    // FutureTask 任务完结，因为发生异常。
    private static final int EXCEPTIONAL  = 3;
    // FutureTask 任务完结，因为取消任务
    private static final int CANCELLED    = 4;
    // FutureTask 任务完结，也是取消任务，不过发起了中断运行任务线程的中断请求
    private static final int INTERRUPTING = 5;
    // FutureTask 任务完结，也是取消任务，已经完成了中断运行任务线程的中断请求
    private static final int INTERRUPTED  = 6;
}
```

## 3. FutureTask 中的阻塞链表

由于有多个线程，所以要有一个变量表示开启 callable.run() 的线程 runner，其他线程都只执行了 futureTask.get()，只有这个 runner 线程是执行 futureTask.run() 开启 callable.run() 的。

如果有多个线程调用 futureTask.get() ，而 callable.run() 恰好在阻塞，那么这些线程都会被封装为链表的形式，等到 callable 执行结束会挨个唤醒。

```java
public class FutureTask<V> implements RunnableFuture<V> {
	// 任务的执行状态
    private volatile int state;
    // 新建，未执行
    private static final int NEW          = 0;
    // 正在执行，未执行结束
    private static final int COMPLETING   = 1;
    // 已执行结束，正常执行结束
    private static final int NORMAL       = 2;
    // 已执行结束，异常执行结束
    private static final int EXCEPTIONAL  = 3;
    // 已执行结束，被停止
    private static final int CANCELLED    = 4;
    // 已执行结束，发起了中断请求
    private static final int INTERRUPTING = 5;
    // 已执行结束，完成了中断请求
    private static final int INTERRUPTED  = 6;

	// 需要执行的任务
    private Callable<V> callable;
	// 执行结果，如果是正常执行，outcome为结果。如果是异常执行，outcome是异常。
    private Object outcome; 
    // 调用 callable.run() 的线程。
    private volatile Thread runner;
    
    // 所有被阻塞的链表节点，内含有线程
    private volatile WaitNode waiters;
    static final class WaitNode {
        volatile Thread thread;
        volatile WaitNode next;
        WaitNode() { thread = Thread.currentThread(); }
    }
}
```

作为链表节点 WaitNode，其实 FutureTask 中并没有实现其他内容去维护这个链表，而是简单的使用 Unsafe 去执行将节点添加到链表中的操作。

```java
private static final sun.misc.Unsafe UNSAFE;
// state变量的地址
private static final long stateOffset;
// runner线程的地址
private static final long runnerOffset;
// 其他调用 futureTask.get() 进入阻塞的线程的地址
private static final long waitersOffset;
static {
    try {
        UNSAFE = sun.misc.Unsafe.getUnsafe();
        Class<?> k = FutureTask.class;
        stateOffset = UNSAFE.objectFieldOffset
            (k.getDeclaredField("state"));
        runnerOffset = UNSAFE.objectFieldOffset
            (k.getDeclaredField("runner"));
        waitersOffset = UNSAFE.objectFieldOffset
            (k.getDeclaredField("waiters"));
    } catch (Exception e) {
        throw new Error(e);
    }
}
```

通过 Unsafe 得到 state、runner、waiter的地址，以后就可以用 Unsafe.CAS() 操作这些变量。

到现在，FutureTask 的变量全部介绍完成，贴一下代码：

```java
public class FutureTask<V> implements RunnableFuture<V> {
	// 任务的执行状态
    private volatile int state;
    // 新建，未执行
    private static final int NEW          = 0;
    // 正在执行，未执行结束
    private static final int COMPLETING   = 1;
    // 已执行结束，正常执行结束
    private static final int NORMAL       = 2;
    // 已执行结束，异常执行结束
    private static final int EXCEPTIONAL  = 3;
    // 已执行结束，被停止
    private static final int CANCELLED    = 4;
    // 已执行结束，发起了中断请求
    private static final int INTERRUPTING = 5;
    // 已执行结束，完成了中断请求
    private static final int INTERRUPTED  = 6;

	// 需要执行的任务
    private Callable<V> callable;
	// 执行结果，如果是正常执行，outcome为结果。如果是异常执行，outcome是异常。
    private Object outcome; 
    // 调用 callable.run() 的线程。
    private volatile Thread runner;
    
    // 所有被阻塞的链表节点，内含有线程
    private volatile WaitNode waiters;
    static final class WaitNode {
        volatile Thread thread;
        volatile WaitNode next;
        WaitNode() { thread = Thread.currentThread(); }
    }
    
    private static final sun.misc.Unsafe UNSAFE;
    // state变量的地址
    private static final long stateOffset;
    // runner线程的地址
    private static final long runnerOffset;
    // 其他调用 futureTask.get() 进入阻塞的线程的地址
    private static final long waitersOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> k = FutureTask.class;
            stateOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("state"));
            runnerOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("runner"));
            waitersOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField("waiters"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}
```

## 4. FutureTask.run()

如果让咱们借助上面的变量实现 run方法如何实现？

首先要做判断，可能有多个线程调用了 FutureTask.run()但是只有一个可以成功调用，如何判断？state变量和runnerOfferset变量

```java
if (state != NEW ||
    !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                 null, Thread.currentThread())) {
    return;
}
```

- state != NEW ：callable已经被别的线程运行了，state不再是新创建了。
- 使用 CAS 将运行 callable 的 runner 从 null 改为此线程，如果失败了说明 runner不为空或者为空但是 CAS竞争失败。

这个判断是为了防止任务多次执行。如果能走出这个判断，也就拿到了执行任务的权利，此时的 runner已经为本线程了。

```java
try {
    Callable<V> c = callable;
    if (c != null && state == NEW) {
        V result;
        boolean ran;
        try {
            result = c.call();
            ran = true;
        } catch (Throwable ex) {
            result = null;
            ran = false;
            setException(ex);
        }
        if (ran)
            set(result);
    }
} finally {
    // runner must be non-null until state is settled to
    // prevent concurrent calls to run()
    runner = null;
    // state must be re-read after nulling runner to prevent
    // leaked interrupts
    int s = state;
    if (s >= INTERRUPTING)
        handlePossibleCancellationInterrupt(s);
}
```

callable.call() 可能阻塞，也可能不阻塞。如果不阻塞那么直接调用 set(result) 将结果交给 outcome，如果阻塞，set方法不会这么早执行的。

- result = c.call() ：执行任务
- set(result) ：将结果赋值给 outcome，将全部阻塞的线程唤醒
- finally ：任务执行完了，runner置为空，如果状态为interrupting，那就要让线程继续让出执行权

set方法会揭晓一些我前面说的不完全明白的东西，来看：

```java
protected void set(V v) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}
```

当任务执行完毕的时候，set() 调用 CAS 将 state 从 NEW 改为 COMPLETING，如果更改成功，就将任务执行的结果赋值给 outcome，再用 CAS 将 state 改为 NORMAL，此时，任务正式执行完成。但是接下来还需要唤醒其他等待结果的线程 ：finishCompletion()

```java
private void finishCompletion() {
	// 为什么要双重循环，其实这里我不懂。
    for (WaitNode q; (q = waiters) != null;) {
        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
            for (;;) {
                // 取出此节点的线程，调用 LockSupport.unpatk(t) 唤醒此节点
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                // 如果q.next为空，说明 q是最后一个节点，退出循环
                if (next == null)
                    break;
                // 如果 q.next 不为空，继续循环，目的是将所有节点的线程唤醒
                // 方便gc
                q.next = null; 
                // 将 q 改为 next
                q = next;
            }
            break;
        }
    }
	// 钩子函数，交给程序员实现
    done();
	// 任务执行完毕，所有等待线程已经唤醒，可以将 callable 置为空
    callable = null;        // to reduce footprint
}
```

run方法的逻辑已经分析完了，现在问你一个问题，runner 在 waiters 链表中吗？

好了，再看着源码分析一下执行流程 ：

```java
public void run() {
    // 1. 判断callable是否已经被别的线程启动
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    // 走到这里说明callable没有被别的线程启动，此线程可以启动 callable
    try {
        // 拿到 callable
        Callable<V> c = callable;
        // 再次判断
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                // 执行任务
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            // 如果ran为true, 可以做三件事:
            // 1. 将状态改为 COMPLETING
            // 2. 将结果赋值给 outcome
            // 3. 将状态改为 Normal
            // 4. 唤醒所有阻塞的线程
            if (ran)
                set(result);
        }
    } finally {
        // 执行完了将 runner置为空
        runner = null;
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}

// 1. 将状态改为 COMPLETING
// 2. 将结果赋值给 outcome
// 3. 将状态改为 Normal
// 4. 唤醒所有阻塞的线程
protected void set(V v) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}

// 唤醒所有阻塞等待的线程
private void finishCompletion() {
    // assert state > COMPLETING;
    for (WaitNode q; (q = waiters) != null;) {
        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null; // unlink to help gc
                q = next;
            }
            break;
        }
    }
    done();
    callable = null;        // to reduce footprint
}
```

## 5. FutureTask.get()

get() 就是FutureTask 阻塞的核心了，它阻塞的不是 callable线程，而是调用 FutureTask.get() 的线程，所以还是比较好实现的。

一共有两种实现方式，一种是无限阻塞，一种是限时阻塞。先来看一下无限阻塞。

```java
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s <= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}
```

获取 state变量，如果 state <= COMPLETING，说明未执行或正在执行，那么就可以阻塞当前线程了。

但是如果 state > COMPLETING，说明有结果了，结果是正常的还是异常的先不论，反正可以返回一个结果。

```java
// timed : 是否为限时阻塞
// nanos : 如果是限时阻塞，限时多久
private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    // 先判断一下是否限时，如果限时，计算出结束限时的时间。
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    // 死循环
    for (;;) {
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }
		// 重新获取当前状态
        int s = state;
        // 如果大于 COMPLETING 说明已经执行完了，将状态返回
        // 由于是死循环遍历，第n次遍历的时候 state总有执行成功那一天
        if (s > COMPLETING) {
            // 第一次循环q肯定为null，但是后面循环就不一定了
            if (q != null)
                q.thread = null;
            return s;
        }
        // 如果正在执行，当前线程让出CPU
        else if (s == COMPLETING) 
            Thread.yield();
        // 如果 q == Null，那我们就要将当前线程封装为 节点，下次循环就可以放到阻塞链表中
        else if (q == null)
            q = new WaitNode();
        // 如果当前线程的节点还没有放入链表中，现在就放入。
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                 q.next = waiters, q);
        // 如果要限时阻塞，获取一下阻塞时间，调用 LockSupport.parkNanos()
        // 不用担心这个线程醒不来，run() 中调用的 finishCompletion() 会将所有 park 的线程 unpark
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos <= 0L) {
                removeWaiter(q);
                return state;
            }
            LockSupport.parkNanos(this, nanos);
        }
        // 否则就直接park
        else
            LockSupport.park(this);
    }
}
```

所有调用 FutureTask.get() 的线程都会进入阻塞链表其实就是挨个挂在 waiters 的 next 上，如果 FutureTask.run() 中走出了 callable.call() ，在 set(result) 时会将所有 park 的线程唤醒。

## 6. 总结

到这里就讲完了，跟小伙伴们讨论的时候感觉难的地方就是 FutureTask 对阻塞链表的管理，比如添加节点、删除节点，并没有用 Java 做，也不能这么说，反正就是 debug 的时候确实看的不太清且。其实 FutureTask 算上注释也才480行，去掉注释估计就 300行了，不难阅读





