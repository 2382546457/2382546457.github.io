---
title: synchronized实现原理
date: 2023-12-21 20:31:50
permalink: /pages/131b6b/
---
## 1. 对象结构

HotSpot 虚拟机中，对象在内存中存储的布局可分为三块区域 ：对象头、实例数据、对齐填充。

- 对象头 ：一般存放三种信息
    - Mark Word ：存储对象的哈希码、GC分代年龄、锁信息
    - Class MetaData Address ：指向对象类型数据的指针
    - 数组长度 ：数组对象有这个，不是数组就没有。
- 实例数据 ：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
- 对齐填充 ：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

![image-20231221200237945](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231221200237945.png)

本篇文章是关于 synchronized 的，所以只介绍 Mark Word中有关锁的部分。

1. bias_lock ：1个字节，对象是否启动偏向锁标记。为0时对象没有偏向锁，为1时表示对象启动偏向锁。
2. lock ：2个字节，锁状态位。
3. ptr_to_heavyweight_monitor ：指向该对象拥有的 Monitor 对象的指针。
4. thread ：如果这个锁是偏向锁，thread 就是这个锁偏向的线程的 ID

bias_lock 与 lock 两个字段组合起来就可以表示 synchronized 可以加的所有锁类型了 ：

| biased_lock | lock | 锁状态   |
| ----------- | ---- | -------- |
| 0           | 01   | 无锁     |
| 1           | 01   | 偏向锁   |
| 0           | 00   | 轻量级锁 |
| 0           | 10   | 重量级锁 |
| 0           | 11   | GC标记   |

## 2. Monitor

在 HotSpot 虚拟机中，Monitor 对象是由 ObjectMonitor 实现的，如下：

```c++
ObjectMonitor() {
    // 重入了几次
    _count = 0;
    // 持有锁的对象的线程
    _owner = NULL;
    // 阻塞等待获取锁的线程集合
    _EntryList = NULL;
    // 调用wait进行等待的线程集合
    _WaitSet = NULL;
}
```

我删除了很多东西，最重要的就是这几个 ：

1. _owner ：持有锁的线程
2. _count ：获取了多少次锁，实现可重入功能
3. _EntryList ：所有阻塞等待获取锁的线程
4. _WaitSet ：所有调用 wait() 方法，等待被 notify 的线程

## 3. 锁升级

锁解决了数据的并发安全问题，但是同样带来了性能的下降，所以 synchronized 被优化了，引入了上面介绍的偏向锁、轻量级锁，优化后的 synchronized 共有三种锁 ：

1. 偏向锁 ：只有一个线程争抢资源的时候，将线程拥有者标识为当前线程，即 thread 变量设置为此线程的 ID。当出现锁竞争的时候，其他线程将 thread 指向的线程 ID 抹去，偏向锁升级为轻量级锁。
2. 轻量级锁 ：也叫自旋锁，多个线程开始使用 CAS 自旋进行抢锁。当线程自旋超过10次，就将锁升级为重量级锁（默认为10次，后面这个自选次数改为可变的了）
3. 重量级锁 ：不让你 CAS 了，你们 CAS 了这么长时间都没有抢到锁，直接进 EntryList 中等着吧。

锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。也可以直接从无锁到重量级锁。

## 4. 锁降级

锁可以降级，但是不能降为偏向锁。

- 恢复锁对象的markword对象头;
- 重置ObjectMonitor，然后将该ObjectMonitor放入全局空闲列表，等待后续使用。