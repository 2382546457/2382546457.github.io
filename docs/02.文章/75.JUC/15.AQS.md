---
title: AQS
date: 2023-07-26 21:52:53
permalink: /pages/05d6a0/
---

::: note 前言
 第一次学习JUC的时候也学习了AQS，不过对于当时的我颇有难度，也就无疾而终了，现在再次学习，希望能对它有一定的理解。
:::
## 1. 简述

JUC包下的很多类都依靠 AQS，在知道 AQS 是一个抽象类之后，我一度以为 `AQS是JUC的基石` 这句话的意思是：JUC包下很多类都实现/继承了 AQS，但是我错了。

![image-20230726160739381](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726160739381.png)

可以看到，AQS有很多名为 `Sync` 的实现类，这些 Sync 分布在不同的类中，那么  `AQS是JUC的基石` 的意思就应该是 ：<font color=Green>**当一个工具类想要使用 AQS 提供的基本功能时，会写一个内部类Sync继承 AQS ，接下来去实现这个工具类**</font>。

那么来介绍一下 AQS 是什么 ：AQS的全称为 **AbstractQueuedSynchronizer**，翻译过来就是 **抽象队列同步器**。

它是**一个用来构建锁和其他同步组件的基础框架**，即 `AQS是JUC的基石`。它提供了一些功能与属性：

- 属性 ：双向链表（也可以说是双向队列或是同步队列）、等待队列、status属性值
- 功能 ：
    - 获取锁（未安全实现）
    - 释放锁（未完全实现）
    - 将线程添加到队列中
    - ....

当某个类想要使用AQS提供的基本功能时，只需要继承它并实现那些还没有实现的方法就可以，这是典型的`模板方法设计模式`。

>当然如上所说，在JUC中并没有选择让工具类本身去实现AQS，而是选择让内部类实现。
>
>正好我最近在看西方小说，写到这里自然想到了 ：贵族本身不需要武力，但是会派自己的心腹去获取某项武力并帮助自己。

## 2. AQS的一些重要属性

### 2.1 Node

现在可以抽空看一下右边的文章目录，是不是有`同步队列`和`等待队列`这两个小标题？这个Node类就是组成同步队列和阻塞队列的节点。原本想要在同步队列中直接将 Node 引出，但是会因此让文章变得混乱，所以我决定先介绍Node。

AQS中有一个静态内部类：`Node`。这个Node可以抽象为线程，也许说它就代表着线程更加妥当。

```java
static final class Node {
    // 此Node代表的线程
    volatile Thread thread;
    
    volatile Node prev;

    volatile Node next;
    
    Node nextWaiter;
}
```

如果想要实现一个单向链表你会怎么做？首先创建一个Node类代表节点，在Node中添加节点的值和next指针

```java
public class Node {
    private int date;
    private Node next;
}
```

单向链表只需要一个next值连接下一个节点，而双向链表需要每一个节点有 `前驱`和`后继`两个属性。那么 AQS 中的Node不就是这样吗？同时想要它有`队列`的功能，仅仅提供先进先出的方法就可以。

（话说String类为什么不可变？因为没有提供改变数组的方法~~ 这也让我明白了代码是程序员写的，我们拥有绝对支配的能力）

Node 中提供了 `predecessor()` 方法用于寻找此节点的上一个节点。

```java
final Node predecessor() throws NullPointerException {
    Node p = prev;
    if (p == null)
        throw new NullPointerException();
    else
        return p;
}
```

这里的`prev`和`next`是用来连接`同步队列`的，与`等待队列`没有关系。真正连接 Node 成为等待队列的是`nextWaiter`

```java
Node nextWaiter;
```



因为Node代表着线程，所以它提供了几个状态值来代表线程在队列中的状态 ：

```java
// 此任务已取消 (这个Node节点马上就会从链表中删除)
static final int CANCELLED =  1;

// 当前节点的下一个节点挂起了
static final int SIGNAL    = -1;

// 当前节点在等待队列中
static final int CONDITION = -2;

// 下一次共享式同步状态将会被无条件地传播下去
static final int PROPAGATE = -3;
```

由于很多东西还没有说明，所以你大概了解一下这些状态值，并且一个Node创建的时候默认状态值为 0。

谁拥有这些状态值呢？**waitStatus**

```java
volatile int waitStatus;
```

要判断这个节点线程的状态时，只需要判断 `waitStatus`的值是上述状态中的哪一个就行。

>AQS中的 Node 是共用的，也就是说不管是 `ReentrantLock`还是  `CountDownLatch`，它们都会将线程包装为这个Node。
> 
> 换一种说法，**在AQS体系中，线程就是以 Node 的形式保存的**

### 2.2 同步队列

这个同步队列是由双向链表实现的。从上面所说的可以知道，AQS中的同步队列是由Node组成、Node中的prev和next连接。

只有节点肯定不行，AQS中有两个属性控制这个双向链表，head 和 tail 。即头和尾。头是一个虚拟节点，它一直是NULL并不会代表哪个线程；尾是有具体意义的，会代表某一个线程。即：除了头节点为空，其他节点都代表一个线程。

![同步队列](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726171337940.png)

### 2.3 等待队列

AQS中的等待队列是由Node组成，Node中的`nextWaiter`连接成为等待队列。

![image-20230726172213584](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726172213584.png)

奇怪的是，当我在AQS中寻找与管理同步队列的head和tail类似的属性时并没有找到，但我还是找到了管理等待队列的属性：`firstWaiter`、`lastWaiter`

它在AQS另一个内部类中 ：`ConditionObject`。

说来也是，就 “等待队列” 这个词而言，`等待`肯定是它的一大特点。那么如何实现等待？一个是Object类中的wait方法，另一个就是Condition的await方法。那么就好解释了：

>ConditionObject提供了让Node等待的方法，例如await、signal...
>
>同时使用firstWaiter和lastWaiter控制/管理等待队列。

### 2.4 state状态值

这是一个非常重要的属性。

```java
private volatile int state;
```

毕竟AQS提供的是并发支持，有并发就要有锁，那么这个锁是什么状态的时候代表被线程持有呢？

_**state 不为 0 的时候证明这个锁被占有了。**_

同时，由于 AQS 并没有规定这个值必须怎样怎样，所以实现类们也把 state 用的花里胡哨，例如：

1. 在 ReentrantLock 中，state 为 0 代表锁还未被占有，如果为 1 代表被占有，如果大于 1 代表重入。
2. 在 CountDownLatch 中，state 代表着任务数量。



### 2.5 小结

1. AQS有两个重要的属性：Node和state。

2. state 是状态值，一般来说代表锁是否被持有，不过具体含义要看实现类如何操作。

3. Node：是线程的代表，线程会被封装为Node在AQS中存在。

   Node中有三个属性：next、prev、nextWaiter。

    - next和prev连接Node成为`同步队列`。控制同步队列的属性 head 和 tail 在AQS中。
    - nextWaiter连接Node成为`等待队列`。控制等待队列的属性 firstWaiter 和 lastWaiter 在 ConditionObject 中（AQS的内部类）
    - （至于同步队列和等待队列到底有什么用，我想在后续慢慢展开。）

![image-20230726212426652](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230726212426652.png)

## 

