---
title: 5. 定时任务是如何执行的
date: 2023-11-20 12:56:32
permalink: /pages/5531a6/
---

## 1. 定义定时任务

定时任务在 Xxl-Job 中以什么形式存在呢？肯定要有一个类封装它。

首先，我们先定义接口，接口规定的是行为，一个任务需要有哪些行为？执行、初始化、销毁。

但是并非所有任务都需要初始化、销毁，所以我们将 IJobHandler 定义为抽象类，给初始化和销毁方法默认实现。

```java
public abstract class IJobHandler {

	public abstract void execute() throws Exception;

	public void init() throws Exception {

	}

	public void destroy() throws Exception {

	}
}
```

一个方法想要执行，肯定要有Class对象、Method方法，同时我想让功能更加丰富，于是给每一个定时任务加上初始化方法、销毁方法。

```java
public class MethodJobHandler extends IJobHandler {
    // bean对象的class
    private final Object target;
    // 需要执行的method
    private final Method method;
    // 初始化和销毁方法
    private Method initMethod;
    private Method destroyMethod;

    public MethodJobHandler(Object target, Method method, Method initMethod, Method destroyMethod) {
        this.target = target;
        this.method = method;

        this.initMethod = initMethod;
        this.destroyMethod = destroyMethod;
    }

    @Override
    public void execute() throws Exception {
        Class<?>[] paramTypes = method.getParameterTypes();
        if (paramTypes.length > 0) {
            method.invoke(target, new Object[paramTypes.length]);       // method-param can not be primitive-types
        } else {
            method.invoke(target);
        }
    }

    @Override
    public void init() throws Exception {
        if(initMethod != null) {
            initMethod.invoke(target);
        }
    }

    @Override
    public void destroy() throws Exception {
        if(destroyMethod != null) {
            destroyMethod.invoke(target);
        }
    }

    @Override
    public String toString() {
        return super.toString()+"["+ target.getClass() + "#" + method.getName() +"]";
    }
}
```

其实上面的逻辑不难对吧，一共就三个方法，执行、初始化、销毁。

- 执行 ：如果没有参数直接就 method.invoke(target)
- 初始化 ：如果初始化Method不为空就执行
- 销毁 ：如果

当想要执行一个定时任务的时候，只需要先 new MethodJobHandler，然后调用 jobhandler.executor() 就可执行。

## 2. 收集定时任务

想要执行定时任务，肯定要有定时任务，要知道开发人员到底写了哪些定时任务。上面说了封装的形式，所以我们需要将所有定时任务找出来封装为 MethodJobHandler

来看看之前我们写的定时任务代码：

```java
@Component
public class SampleXxlJob {

    @XxlJob("demoJobHandler")
    public void demoJobHandler() throws Exception {
        System.out.println("简单任务实例执行了");
    }
}
```

如果是你，如何获取这个任务呢？由于 SampleXxlJob 这个类已经被注入到 Spring 容器中了，那么我们获取 Spring 容器遍历容器中的所有Bean，如果某个 Bean 有 @XxlJob 这个注解，那么这个 Bean + Method就是我们要找的定时任务。

肯定要由执行器做这种事情，因为我们的项目引入的是执行器依赖，换言之，我们的项目现在就是一个执行器了。

所以我将这个“收集定时任务”的类叫做 `XxlJobSpringExecutor`

```java
public class XxlJobSpringExecutor implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}
```

通过上述代码我就可以拿到 Spring 的上下文 applicationContext，通过 applicatoiinContext 可以获取所有Bean.

现在又有一个新问题：什么时候开始收集定时任务呢？Spring容器初始化前？Spring容器初始化后？

那肯定是 Spring 的容器初始化之后了，所以我们要实现 `SmartInitializingSingleton`，在所有单例对象准备好之后，我们开始收集任务。

```java
public class XxlJobSpringExecutor implements ApplicationContextAware, SmartInitializingSingleton {
    
    @Override
    public void afterSingletonsInstantiated() {
        // 在这里收集定时任务
        initJobHandlerMethodRepository(applicationContext);
    }
   
    private static ApplicationContext applicationContext;
    

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}
```

收集定时任务的代码挺多的，我在这里单独放出来：

```java
private void initJobHandlerMethodRepository(ApplicationContext applicationContext) {
        // 容器判空
        if (applicationContext == null) {
            return;
        }
        // 拿到所有bean对象的名字
    	// getBeanNamesForType有三个参数:
    	// type : 类型
    	// includeNonSingletons : 是否包含多实例对象
    	// allowEagerInit : 是否包含懒加载对象
        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
        for (String beanDefinitionName : beanDefinitionNames) {

            // 通过name拿到bean对象
            Object bean = null;
            Lazy onBean = applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);
            if (onBean!=null){
                logger.debug("xxl-job annotation scan, skip @Lazy Bean:{}", beanDefinitionName);
                continue;
            }else {
                bean = applicationContext.getBean(beanDefinitionName);
            }

            // 这个Map用于收集定时任务，
            // Method : 定时任务方法
            // XxlJob : 这个定时任务的注解，通过 XxlJob可以得到定时任务的名字
            Map<Method, XxlJob> annotatedMethods = null;   
            try {
                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                        new MethodIntrospector.MetadataLookup<XxlJob>() {
                            @Override
                            public XxlJob inspect(Method method) {
                                return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                            }
                        });
            } catch (Throwable ex) {
                logger.error("xxl-job method-jobhandler resolve error for bean[" + beanDefinitionName + "].", ex);
            }
            // 如果这个Bean中没有定时任务，跳过
            if (annotatedMethods==null || annotatedMethods.isEmpty()) {
                continue;
            }

            // 已经收集到该Bean的所有定时任务，要把它统一放在一个地方
            // registJobHandler
            for (Map.Entry<Method, XxlJob> methodXxlJobEntry : annotatedMethods.entrySet()) {
                Method executeMethod = methodXxlJobEntry.getKey();
                XxlJob xxlJob = methodXxlJobEntry.getValue();
                // regist
                registJobHandler(xxlJob, bean, executeMethod);
            }

        }
    }
```

1. 拿到所有 Bean 对象的名字，遍历名字，根据名字获取Bean对象
2. 使用 Spring 提供的工具类 MethodIntrospector.selectMethods 查看一个类中有没有加了 @XxlJob 注解的方法
3. 如果有，就将这些方法按照 method:xxljob 的形式封装进 Map 中。
4. 将这个 Bean 中所有定时任务注册到某个地方，以便使用
5. 开始遍历下一个 Bean，重复上述步骤

为什么`寻找`和`注册`要分开呢？因为我们现在讲的是整合 Spring，所以才可以通过 Spring 容器快速找到定时任务，但是如果没有集成 Spring 而是其他框架呢？那么`寻找`这一步就可能有很多种实现方式，但是注册不一样，不管你跟多少框架集成，最终你要给我 定时任务的类、方法、xxljob注解，这三样东西，然后注册起来。

所以 `寻找`是一个抽象方法，以便其他框架实现，`注册`是固定的

由于没有和任何框架集成，我将这个类命名为 `XxlJobExecutor`

```java
public class XxlJobExecutor {
    // 存放 MethodJobHandler 的Map容器
    // key : 定时任务的名字
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap<String, IJobHandler>();
    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler){
        logger.info(">>>>>>>>>>> xxl-job register jobhandler success, name:{}, jobHandler:{}", name, jobHandler);
        return jobHandlerRepository.put(name, jobHandler);
    }
    protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if (xxlJob == null) {
            return;
        }

        String name = xxlJob.value();
        //make and simplify the variables since they'll be called several times later
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }
        if (loadJobHandler(name) != null) {
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        executeMethod.setAccessible(true);

        // init and destroy
        Method initMethod = null;
        Method destroyMethod = null;

        if (xxlJob.init().trim().length() > 0) {
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        // registry jobhandler
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }
}
```

registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod)

1. xxlJob ：定时任务头上的注解，含有该任务的名字、初始化方法、销毁方法
2. bean ：该任务方法属于哪个类，需要通过它拿到 class
3. executorMethod ：定时任务的方法

这个方法的总流程：

1. 根据传入的参数获取定时任务的 名字、class对象、方法名
2. 检查参数，并且根据定时任务的名字判断是否已经出现过，不允许任务名重复
3. 如果初始化方法、销毁方法不为空，得到这两个方法
4. 将 class对象、定时任务方法、初始化方法、销毁方法 封装为 MethodJobHandler ，并且以方法名为 key 放入 Map

以后就可以通过定时任务的名称来找到 MethodJobHandler，使用 executor() 来执行。

```java
public static IJobHandler loadJobHandler(String name){
    return jobHandlerRepository.get(name);
}
```

那么现在 收集定时任务的流程为：

1. XxlJobSpringExecutor 找到加了 @XxlJob 注解的方法
2. 注册到 XxlJobExecutor 的 Map 中。

最后，上代码：

```java
public class XxlJobExecutor {
    // 存放 MethodJobHandler 的Map容器
    // key : 定时任务的名字
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap<String, IJobHandler>();
    public static IJobHandler loadJobHandler(String name){
    	return jobHandlerRepository.get(name);
	}
    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler){
        logger.info(">>>>>>>>>>> xxl-job register jobhandler success, name:{}, jobHandler:{}", name, jobHandler);
        return jobHandlerRepository.put(name, jobHandler);
    }
    protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if (xxlJob == null) {
            return;
        }

        String name = xxlJob.value();
        //make and simplify the variables since they'll be called several times later
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }
        if (loadJobHandler(name) != null) {
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        executeMethod.setAccessible(true);

        // init and destroy
        Method initMethod = null;
        Method destroyMethod = null;

        if (xxlJob.init().trim().length() > 0) {
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        // registry jobhandler
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }
}
```

```java
public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware, SmartInitializingSingleton, DisposableBean {
    @Override
    public void afterSingletonsInstantiated() {
        // 在这里收集定时任务
        initJobHandlerMethodRepository(applicationContext);
    }
   
    private static ApplicationContext applicationContext;
    

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    private void initJobHandlerMethodRepository(ApplicationContext applicationContext) {
        if (applicationContext == null) {
            return;
        }
        // init job handler from method
        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
        for (String beanDefinitionName : beanDefinitionNames) {

            // get bean
            Object bean = null;
            Lazy onBean = applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);
            if (onBean!=null){
                logger.debug("xxl-job annotation scan, skip @Lazy Bean:{}", beanDefinitionName);
                continue;
            }else {
                bean = applicationContext.getBean(beanDefinitionName);
            }

            // filter method
            Map<Method, XxlJob> annotatedMethods = null;   // referred to ：org.springframework.context.event.EventListenerMethodProcessor.processBean
            try {
                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                        new MethodIntrospector.MetadataLookup<XxlJob>() {
                            @Override
                            public XxlJob inspect(Method method) {
                                return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                            }
                        });
            } catch (Throwable ex) {
                logger.error("xxl-job method-jobhandler resolve error for bean[" + beanDefinitionName + "].", ex);
            }
            if (annotatedMethods==null || annotatedMethods.isEmpty()) {
                continue;
            }

            // generate and regist method job handler
            for (Map.Entry<Method, XxlJob> methodXxlJobEntry : annotatedMethods.entrySet()) {
                Method executeMethod = methodXxlJobEntry.getKey();
                XxlJob xxlJob = methodXxlJobEntry.getValue();
                // regist
                registJobHandler(xxlJob, bean, executeMethod);
            }

        }
    }
}
```

## 3. TriggerParam

调度参数，什么叫调度参数？就是调度中心从数据库中查找到要执行的任务后，将这个参数发送给执行器，执行器根据调度参数内的值进行执行。

如果一个任务3s执行一次，一次执行5s，那么这个任务就活该被丢弃吗？不是，

>这些调度参数如果来不及执行会被放入阻塞队列中等待被取出执行。
>
>我后面会称每一个任务的每一次执行为**调度参数**

```java
public class TriggerParam implements Serializable {
    private static final long serialVersionUID = 42L;

    /**
     * 任务id
     */
    private int jobId;

    /**
     * 执行定时任务的方法的全限定名
     */
    private String executorHandler;

    /**
     * 定时任务的参数
     */
    private String executorParams;

    /**
     * 定时任务的阻塞策略                <br></br>
     * 当一个定时任务想要执行，但是负责该任务的线程正在工作时会使用这个阻塞策略判断
     */
    private String executorBlockStrategy;

    /**
     * 任务的过期时间          <br></br>
     * 如果开启了过期时间，执行任务时会额外创建一个新线程执行任务，
     * 之前的线程负责监督新线程执行任务时间是否超时
     */
    private int executorTimeout;

    /**
     * 该任务对应的日志的id
     */
    private long logId;

    /**
     * 打日志的时间
     */
    private long logDateTime;

    /**
     * 运行模式
     */
    private String glueType;

    /**
     * 代码文本
     */
    private String glueSource;

    /**
     * 代码文本更新时间
     */
    private long glueUpdatetime;

    /**
     * 分片索引
     */
    private int broadcastIndex;

    /**
     * 分片总数
     */
    private int broadcastTotal;

    public int getJobId() {
        return jobId;
    }
}
```



## 4. 定时任务的执行

一个系统可能有很多定时任务，所以我们肯定不能用单线程去负责所有任务的执行。用线程池？但是线程频繁的创建销毁又太消耗性能。

xxl-job 是以每个线程负责某一个任务的执行，假如某个任务10s执行一次，那么这个线程就可以一直负责此任务的执行，但是如果某些任务是1天执行一次，那我们要想办法让这个线程死去，要不然这个线程没事做还占着资源。

当任务要执行的时候，可以将这个任务放入该线程的阻塞队列中，然后使用 while(true) 方式扫描阻塞队列，并且加一个循环次数，当无效循环30次或者更多，我们希望将这个线程杀死。

```java
public class JobThread extends Thread{
    private static Logger logger = LoggerFactory.getLogger(JobThread.class);
	// 此时这个线程负责的定时任务的id
	private int jobId;
    // 该定时任务的 MethodJobHandler
	private IJobHandler handler;
    // 有任务时就会放到这个阻塞队列中
	private LinkedBlockingQueue<TriggerParam> triggerQueue;
    // 防止重复调度
    private Set<Long> triggerLogIdSet;		
	// 该线程是否还在工作
	private volatile boolean toStop = false;
    // 该线程停止的原因是什么，有可能是长时间没有任务，有可能是开发人员手动关闭定时任务
	private String stopReason;
	// 线程是否正在运行任务，"正在运行"不包括线程循环、阻塞等待任务到来，而是真真正正的正在运行任务
    private boolean running = false;    
    // 线程无效循环次数
	private int idleTimes = 0;			


	public JobThread(int jobId, IJobHandler handler) {
		this.jobId = jobId;
		this.handler = handler;
		this.triggerQueue = new LinkedBlockingQueue<TriggerParam>();
		this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<Long>());

		this.setName("xxl-job, JobThread-"+jobId+"-"+System.currentTimeMillis());
	}
    // 调度中心从数据库中查出将要执行的任务，将这个任务发送给执行器
    // 执行器收到消息后将这次执行放入队列中等待执行
    public ReturnT<String> pushTriggerQueue(TriggerParam triggerParam) {
		// avoid repeat
		if (triggerLogIdSet.contains(triggerParam.getLogId())) {
			logger.info(">>>>>>>>>>> repeate trigger job, logId:{}", triggerParam.getLogId());
			return new ReturnT<String>(ReturnT.FAIL_CODE, "repeate trigger job, logId:" + triggerParam.getLogId());
		}

		triggerLogIdSet.add(triggerParam.getLogId());
		triggerQueue.add(triggerParam);
        return ReturnT.SUCCESS;
	}
    	// 线程是否在工作，或者队列中是否有任务等待执行
        public boolean isRunningOrHasQueue() {
        	return running || triggerQueue.size()>0;
    	}

    @Override
	public void run() {

    	// init
    	try {
			handler.init();
		} catch (Throwable e) {
    		logger.error(e.getMessage(), e);
		}

		// execute
		while(!toStop){
			running = false;
			idleTimes++;

            TriggerParam triggerParam = null;
            try {
				triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
				if (triggerParam!=null) {
					running = true;
					idleTimes = 0;
					triggerLogIdSet.remove(triggerParam.getLogId());
					// 打印日志，表示任务将要执行
					XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
					// just execute
					handler.execute();
				} else {
					if (idleTimes > 30) {
						if(triggerQueue.size() == 0) {	
							XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
						}
					}
				}
			} catch (Throwable e) {
				if (toStop) {
					XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
				}

				// handle result
				StringWriter stringWriter = new StringWriter();
				e.printStackTrace(new PrintWriter(stringWriter));
				String errorMsg = stringWriter.toString();

				XxlJobHelper.handleFail(errorMsg);

				XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
			} finally {
                if(triggerParam != null) {
                    // callback handler info
                    if (!toStop) {
                        // commonm
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        		triggerParam.getLogId(),
								triggerParam.getLogDateTime(),
								XxlJobContext.getXxlJobContext().getHandleCode(),
								XxlJobContext.getXxlJobContext().getHandleMsg() )
						);
                    } else {
                        // is killed
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        		triggerParam.getLogId(),
								triggerParam.getLogDateTime(),
								XxlJobContext.HANDLE_CODE_FAIL,
								stopReason + " [job running, killed]" )
						);
                    }
                }
            }
        }
		// destroy
		try {
			handler.destroy();
		} catch (Throwable e) {
			logger.error(e.getMessage(), e);
		}
		logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
	}
}
```

源代码其实挺复杂的，而且很多东西现在没有讲到，所以我删减了很多，等会补上。

1. 执行初始化方法，进入循环

2. 每次循环都将 idleTimes 加一，从阻塞队列中取值，最多等待三秒，如果超过了就说明现在没有任务，再次循环，如果无效循环30次，就会触发 XxlJobExecutor.removeJobThread 将此线程移除。

3. 如果从阻塞队列中取到了值，将 idleTimes置为0，并将 running = true 表示从现在开始要执行任务了

   打印一下日志，使用 handler.execute() 执行任务。

4. 如果出现异常，除了打印日志之外，执行了 XxlJobHelper.handleFail(errorMsg) 这句话，记住它，等会说

5. 在 finally 块中调用 TriggerCallbackThread.pushCallBack() 将任务执行的结果回调给调度中心，这个暂且不说，后面的章节会完善。

但是现在定时任务的执行功能还不完善，我们之前使用的时候是有 <font color=Blue>超时时间</font> 这个功能的，这个功能该如何实现？我们可以新创建一个线程，将定时任务包装为一个 FutureTask，在执行的时候 future.get(seconds)，如果执行超时，就会出现超时异常，我们将其捕获就可以了。

添加了超时时间功能的代码：

```java
@Override
public void run() {

    // init
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // execute
    while(!toStop){
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        try {
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam!=null) {
                running = true;
                idleTimes = 0;
                triggerLogIdSet.remove(triggerParam.getLogId());
                // 打印日志，表示任务将要执行
                XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
                if (triggerParam.getExecutorTimeout() > 0) {
                    // limit timeout
                    Thread futureThread = null;
                    try {
                        FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
                            @Override
                            public Boolean call() throws Exception {
                                handler.execute();
                                return true;
                            }
                        });
                        futureThread = new Thread(futureTask);
                        futureThread.start();

                        Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } catch (TimeoutException e) {

                        XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
                        XxlJobHelper.log(e);
                    } finally {
                        futureThread.interrupt();
                    }
                } else {
                    // just execute
                    handler.execute();
                }
            } else {
                if (idleTimes > 30) {
                    if(triggerQueue.size() == 0) {	
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            if (toStop) {
                XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            // handle result
            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();

            XxlJobHelper.handleFail(errorMsg);

            XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            if(triggerParam != null) {
                // callback handler info
                if (!toStop) {
                    // commonm
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.getXxlJobContext().getHandleCode(),
                        XxlJobContext.getXxlJobContext().getHandleMsg() )
                                                      );
                } else {
                    // is killed
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job running, killed]" )
                                                      );
                }
            }
        }
    }
    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }
    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
```

## 5. XxlJobContext

在上面的代码中，XxlJobContext 和 XxlJobHelper 出现了很多次，XxlJobHelper 我们在刚才已经试用了，就是记录日志的嘛，但是它不仅仅可以记录日志，还可以修改 XxlJobContext 的状态，那么 XxlJobContext 是什么呢？

```java
public class XxlJobContext {

    public static final int HANDLE_CODE_SUCCESS = 200;
    public static final int HANDLE_CODE_FAIL = 500;
    public static final int HANDLE_CODE_TIMEOUT = 502;

    // ---------------------- base info ----------------------

    /**
     * 任务id
     */
    private final long jobId;

    /**
     * 任务参数
     */
    private final String jobParam;

    /**
     * 任务日志文件的文件名
     */
    private final String jobLogFileName;

    /**
     * 分片索引
     */
    private final int shardIndex;

    /**
     * 分片总数
     */
    private final int shardTotal;

    /**
     * handleCode：执行结果
     *
     *      200 : success
     *      500 : fail
     *      502 : timeout
     *
     */
    private int handleCode;

    /**
     * 执行信息
     */
    private String handleMsg;
    
    private static InheritableThreadLocal<XxlJobContext> contextHolder = new InheritableThreadLocal<XxlJobContext>(); 

    public static void setXxlJobContext(XxlJobContext xxlJobContext){
        contextHolder.set(xxlJobContext);
    }

    public static XxlJobContext getXxlJobContext(){
        return contextHolder.get();
    }

}
```

除了一些基本信息以外，XxlJobContext 提供了 setXxlJobContext 的方法，将 XxlJobContext 放到 ThreadLocal 中，这个 InheritableThreadLocal 继承自 ThreadLocal，作用是可以保证父子线程共用数据。

只要涉及 Context 的都是上下文，XxlJobContext 也不例外，我叫它任务上下文，使用 Context 的作用就是我们可以将某些信息直接放里面，想用的时候直接 XxlJobContext.getXXX() 拿出来，而不是将信息作为方法的参数传来传去的。

那么它什么时候创建？必然是有任务执行的时候创建。

想要更改 XxlJobContext 的数据其实也挺麻烦的

```java
XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
xxlJobContext.setHandlerMsg("xxxxxx");
```

需要这两行代码，所以 XxlJobHelper 给我们封装了一下，比如获取当前正在执行的任务的参数、获取当前正在执行的任务的调度信息、设置当前正在执行的任务的执行结果...

```java
public class XxlJobHelper {

    // ---------------------- base info ----------------------

    /**
     * current JobId
     *
     * @return
     */
    public static long getJobId() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getJobId();
    }

    /**
     * current JobParam
     *
     * @return
     */
    public static String getJobParam() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return null;
        }

        return xxlJobContext.getJobParam();
    }

    // ---------------------- for log ----------------------

    /**
     * current JobLogFileName
     *
     * @return
     */
    public static String getJobLogFileName() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return null;
        }

        return xxlJobContext.getJobLogFileName();
    }

    public static int getShardIndex() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getShardIndex();
    }

    /**
     * current ShardTotal
     *
     * @return
     */
    public static int getShardTotal() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getShardTotal();
    }
    public static boolean handleSuccess(){
        return handleResult(XxlJobContext.HANDLE_CODE_SUCCESS, null);
    }
    public static boolean handleSuccess(String handleMsg) {
        return handleResult(XxlJobContext.HANDLE_CODE_SUCCESS, handleMsg);
    }
    public static boolean handleFail(){
        return handleResult(XxlJobContext.HANDLE_CODE_FAIL, null);
    }

    /**
     * handle fail with log msg
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleFail(String handleMsg) {
        return handleResult(XxlJobContext.HANDLE_CODE_FAIL, handleMsg);
    }

    /**
     * handle timeout
     *
     * @return
     */
    public static boolean handleTimeout(){
        return handleResult(XxlJobContext.HANDLE_CODE_TIMEOUT, null);
    }

    /**
     * handle timeout with log msg
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleTimeout(String handleMsg){
        return handleResult(XxlJobContext.HANDLE_CODE_TIMEOUT, handleMsg);
    }

    /**
     * @param handleCode
     *
     *      200 : success
     *      500 : fail
     *      502 : timeout
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleResult(int handleCode, String handleMsg) {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return false;
        }

        xxlJobContext.setHandleCode(handleCode);
        if (handleMsg != null) {
            xxlJobContext.setHandleMsg(handleMsg);
        }
        return true;
    }

}
```

这代码我就不细讲了，无非就是获取 XxlJobContext，set/get 啥的。你就记住，使用 XxlJobContext 可以获取当前正在执行的任务的信息，而 XxlJobHelper 提供了便于操作它的API。

现在可以贴 JobThread#run 的全部代码了

```java
@Override
public void run() {

    // init
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // execute
    while(!toStop){
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        try {
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam!=null) {
                running = true;
                idleTimes = 0;
                triggerLogIdSet.remove(triggerParam.getLogId());
				// 生成日志文件，这个以后会说
                String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                // 任务刚准备开始执行，是创建 XxlJobContext 的大好时机啊
                XxlJobContext xxlJobContext = new XxlJobContext(
                    triggerParam.getJobId(),
                    triggerParam.getExecutorParams(),
                    logFileName,
                    triggerParam.getBroadcastIndex(),
                    triggerParam.getBroadcastTotal()
                );

                // 将 XxlJobContext 放入 ThreadLocal
                XxlJobContext.setXxlJobContext(xxlJobContext);

                // 打印日志，开始执行!
                XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
				// 如果设置了超时时间，开启新线程，包装为 FutureTask 执行。超时就结束
                if (triggerParam.getExecutorTimeout() > 0) {
                    // limit timeout
                    Thread futureThread = null;
                    try {
                        FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
                            @Override
                            public Boolean call() throws Exception {
								// 由于是开启新线程执行，所以要重新设置一下。
                                XxlJobContext.setXxlJobContext(xxlJobContext);
								// 开始执行
                                handler.execute();
                                // 如果能执行完返回true
                                return true;
                            }
                        });
                        futureThread = new Thread(futureTask);
                        futureThread.start();
						// get结果，指定时间内get不到就抛出异常。
                        Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } catch (TimeoutException e) {

                        XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
                        XxlJobHelper.log(e);

                        // 捕获异常之后除了记录日志，还要将timeout记录在context中。
                        XxlJobHelper.handleTimeout("job execute timeout ");
                    } finally {
                        futureThread.interrupt();
                    }
                } else {
                    // just execute
                    handler.execute();
                }

                // 走到这里如果 handler_code 还是 <= 0，只能说这个任务丢失了
                if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
                    XxlJobHelper.handleFail("job handle result lost.");
                } else {
                    // 否则这个任务就是成功了。因为万一出现异常会被catch到根本不会走到这里
                    String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
                    tempHandleMsg = (tempHandleMsg!=null&&tempHandleMsg.length()>50000)
                        ?tempHandleMsg.substring(0, 50000).concat("...")
                        :tempHandleMsg;
                    XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
                }
                // 打印日志
                XxlJobHelper.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- Result: handleCode="
                                 + XxlJobContext.getXxlJobContext().getHandleCode()
                                 + ", handleMsg = "
                                 + XxlJobContext.getXxlJobContext().getHandleMsg()
                                );

            } else {
                // 如果没有在队列中取出任务，并且已经无效循环了30次 (也就是90s)，将线程销毁
                if (idleTimes > 30) {
                    // 再次重复判断，避免并发情况
                    if(triggerQueue.size() == 0) {	
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            if (toStop) {
                XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            // handle result
            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();
			// 如果出现异常，将任务设置为失败，并填上失败信息
            XxlJobHelper.handleFail(errorMsg);

            XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            // 将此任务的执行结果发送给调度中心，这个先不管。
            if(triggerParam != null) {
                // callback handler info
                if (!toStop) {
                    // commonm
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.getXxlJobContext().getHandleCode(),
                        XxlJobContext.getXxlJobContext().getHandleMsg() )
                                                      );
                } else {
                    // is killed
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job running, killed]" )
                                                      );
                }
            }
        }
    }

    // 能走到这里，说明 toStop变量被设置为true了，有以下两种可能:
    // 1. 开发人员手动关闭定时任务
    // 2. 任务很久没有执行，触发了 XxlJobExecutor.removeJobThread()将线程移除
    // 现在要判断队列中是否还有值，如果是因为第二种情况走出的while循环，根本不会走下面的逻辑
    // 如果定时任务关闭了，将所有这个任务没执行的"次数"全部取出来发送给调度中心，告诉开发人员这些没执行。
    while(triggerQueue !=null && triggerQueue.size()>0){
        TriggerParam triggerParam = triggerQueue.poll();
        if (triggerParam!=null) {
            // is killed
            TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                triggerParam.getLogId(),
                triggerParam.getLogDateTime(),
                XxlJobContext.HANDLE_CODE_FAIL,
                stopReason + " [job not executed, in the job queue, killed.]")
                                              );
        }
    }

    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
```

## 6. JobThread

上面的代码其实已经差不多是JobThread的全部代码了，但是还缺一个销毁方法，因为在 run 方法中使用变量 toStop 让线程无限循环，所以想要让线程停止工作，我们需要将 toStop 设置为 true

```java
public void toStop(String stopReason) {
    this.toStop = true;
    this.stopReason = stopReason;
}
```

这里放出全部 JobThread 的代码：（真的可以下载源码去看，在这里看不能 ctrl 点击，难受）

为了方便阅读，我将 `判断是否有超时时间` 那段逻辑封装为了 doExecutor 方法，希望你能理解。

```java
public class JobThread extends Thread {
    private static Logger logger = LoggerFactory.getLogger(JobThread.class);

    /**
     * 定时任务的id
     */
    private int jobId;

    /**
     * 此任务绑定的对象
     */
    private IJobHandler handler;

    /**
     * 内含需要被执行的定时任务(触发器参数)
     */
    private LinkedBlockingQueue<TriggerParam> triggerQueue;

    /**
     * 正在调度的任务的日志id集合(线程安全)
     */
    private Set<Long> triggerLogIdSet;

    /**
     * 该组件是否结束，如果这个组件结束，说明该线程正在负责的定时任务被取消了
     */
    private volatile boolean toStop = false;

    /**
     * 该任务被取消的原因
     */
    private String stopReason;

    /**
     * 该线程是否正在运行(正在运行任务，如果只是等待从队列中取任务不算运行中)
     */
    private boolean running = false;

    /**
     * 空转次数，达到一定次数便销毁该线程，连阻塞都不让它阻塞
     */
    private int idleTimes = 0;

    public JobThread(int jobId, IJobHandler handler) {
        this.jobId = jobId;
        this.handler = handler;
        this.triggerQueue = new LinkedBlockingQueue<>();
        this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<>());
        this.setName("xxl-job, JobThread - " + jobId + " - " + System.currentTimeMillis());
    }

    /**
     * 调度参数放入调度队列
     *
     * @param triggerParam
     */
    public Result pushTriggerQueue(TriggerParam triggerParam) {
        // 如果日志id集合中包含此调度参数，说明可能重复调度了
        if (triggerLogIdSet.contains(triggerParam.getLogId())) {
            logger.info(">>>>>>>>>>>> repeate trigger job, logId: {}", triggerParam.getLogId());
            return Result.error("repeate trigger job, logId:" + triggerParam.getLogId());
        }
        triggerLogIdSet.add(triggerParam.getLogId());
        triggerQueue.add(triggerParam);
        return Result.success();
    }

    /**
     * 判断该线程是否正在忙碌，正在运行任务、阻塞队列中有调度参数等待执行 代表忙碌
     */
    public boolean isRunningOrHasQueue() {
        return running || !triggerQueue.isEmpty();
    }

    @Override
    public void run() {
        // 执行初始化方法
        runInitMethod();
        // 开始执行
        while (!toStop) {
            // 刚进入循环不算执行，得到调度参数才算执行
            running = false;
            idleTimes += 1;
            TriggerParam triggerParam = null;
            try {
                triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
                if (triggerParam == null) {
                    // 如果阻塞3s没有调度参数，并且现在已经循环了30次，队列中还是没有数据，得，销毁线程
                    if (idleTimes > 30 && triggerQueue.isEmpty()) {
                        // 调用XxlJobExecutor.removeJobThread() 去销毁线程
                        XxlJobExecutor.removeJobThread(jobId, "太久不执行，线程销毁了");
                    }
                } else {
                    // 调度参数不为空，将running改为true, 空转次数改为0
                    running = true;
                    idleTimes = 0;
                    triggerLogIdSet.remove(triggerParam.getLogId());
                    String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                    XxlJobContext xxlJobContext = new XxlJobContext(
                            triggerParam.getJobId(),
                            triggerParam.getExecutorParams(),
                            logFileName,
                            triggerParam.getBroadcastIndex(),
                            triggerParam.getBroadcastTotal()
                    );
                    XxlJobContext.setXxlJobContext(xxlJobContext);
                    // 记录日志，开始执行
                    XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
                    // 执行定时任务，根据是否设置超时时间来执行。
                    // 如果没有设置超时时间就直接执行。 如果设置了超时时间就开启子线程，使用 FutureTask 执行。
                    doExecute(triggerParam, xxlJobContext);

                    // 判断执行结果
                    if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
                        XxlJobHelper.handleFail("job handle result lost.");
                    } else {
                        // 如果执行结果大于0，不管成功还是失败就直接记录消息，等回调线程去回调。如果执行成功了handleMsg为空
                        String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
                        tempHandleMsg = (tempHandleMsg != null && tempHandleMsg.length() > 50000) ? tempHandleMsg.substring(0, 50000).concat("...") : tempHandleMsg;
                        XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
                    }
                    // 回调的执行结果咱不管，现在的执行结果先记录日志
                    XxlJobHelper.log("<br>------------ xxl-job job execute end(finish)-------------<br>------------- Result: handleCode=" +
                            XxlJobContext.getXxlJobContext().getHandleCode() +
                            ", handleMsg = " +
                            XxlJobContext.getXxlJobContext().getHandleMsg()
                    );
                }
            } catch (Exception e) {
                if (toStop) {
                    // 如果线程停止了，记录停止原因、异常
                    XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
                    StringWriter stringWriter = new StringWriter();
                    e.printStackTrace(new PrintWriter(stringWriter));
                    String errorMessage = stringWriter.toString();
                    // 将XxlJobContext中任务的执行状态改为失败
                    XxlJobHelper.handleFail(errorMessage);
                    XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMessage +
                            "<br>----------- xxl-job job execute end(error)");
                }
            } finally {
                // 在finally中执行将日志回调给调度中心的操作
                if (triggerParam != null) {
                    // 如果线程没有停止，不管任务执行成功还是失败，回调给调度中心即可。
                    // 如果线程被终止了，将stopReason发送给调度中心
                    if (!toStop) {
                        TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.getXxlJobContext().getHandleCode(),
                                XxlJobContext.getXxlJobContext().getHandleMsg()
                        ));
                    } else {
                        TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.HANDLE_CODE_FAIL,
                                stopReason + "[job running, killed]"
                        ));
                    }
                }
            }

        }

        // 退出while循环，最后将队列中没来得及执行的数据拿出来回调回去，告诉调度中心这些数据没有执行
        while (triggerQueue != null && !triggerQueue.isEmpty()) {
            TriggerParam triggerParam = triggerQueue.poll();
            if (triggerParam == null) {
                continue;
            }
            TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                    triggerParam.getLogId(),
                    triggerParam.getLogDateTime(),
                    XxlJobContext.HANDLE_CODE_FAIL,
                    stopReason + " [job not executed, in the job queue, killed.]"
            ));
        }
        // 执行销毁方法
        runDestroyMethod();
    }

    private void runInitMethod() {
        try {
            handler.init();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

    private void runDestroyMethod() {
        try {
            handler.destroy();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

    /**
     * 执行定时任务，根据是否设置超时时间来执行。
     * 如果设置了超时时间就开启子线程，使用 FutureTask 执行。
     * 如果没有设置超时时间就直接执行
     *
     * @param triggerParam
     * @param xxlJobContext
     */
    private void doExecute(TriggerParam triggerParam, XxlJobContext xxlJobContext) throws Exception {
        // 没有设置超时时间，直接执行，设置了超时时间，开启子线程执行，此线程监督子线程执行
        if (triggerParam.getExecutorTimeout() == 0) {
            try {
                handler.execute();
            } catch (Exception e) {
                XxlJobHelper.log("<br>-------------- xxl-job job execute timeout");
                XxlJobHelper.log(e);
                XxlJobHelper.handleFail("job execute fail, exception message: " + e.getMessage());
            }
        } else {
            Thread futureThread = null;
            try {
                FutureTask<Boolean> futureTask = new FutureTask<>(new Callable<Boolean>() {
                    @Override
                    public Boolean call() throws Exception {
                        XxlJobContext.setXxlJobContext(xxlJobContext);
                        handler.execute();
                        return true;
                    }
                });
                // 创建并启动线程，get结果，如果指定时间get不到，说明超时
                futureThread = new Thread(futureTask);
                futureThread.start();
                Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                XxlJobHelper.log("<br>-------------- xxl-job job execute timeout");
                XxlJobHelper.log(e);
                // 将超时设置到 XxlJobContext 中
                XxlJobHelper.handleTimeout("job execute timeout");
            } finally {
                futureThread.interrupt();
            }
        }
    }

    public void toStop(String stopReason) {
        toStop = true;
        this.stopReason = stopReason;
    }


    public IJobHandler getHandler() {
        return handler;
    }

}
```



## 7. 执行器对 JobThread 的管理

难道所有任务刚被调度就一定有线程执行它吗？执行器拿到调度参数 (triggerParam) 后怎么找到负责执行这个任务的线程？所以在 Xxl-Job 中一定会将 JobThread 集中管理，并提供创建、销毁、查找的方法。

XxlJobExecutor提供了这些功能：

```java
// ---------------------- job thread repository ----------------------
// 存放 JobThread 的Map
// key : 定时任务id
// JobThread : 负责该任务执行的线程
private static ConcurrentMap<Integer, JobThread> jobThreadRepository = new ConcurrentHashMap<Integer, JobThread>();

// 注册任务，将任务以线程的方式包装起来
public static JobThread registJobThread(int jobId, IJobHandler handler, String removeOldReason){
    // 创建一个新线程，启动它
    JobThread newJobThread = new JobThread(jobId, handler);
    newJobThread.start();
	// 将这个id-newThread放入Map，如果返回的oldJobThread不为空，说明开发人员在web端更改了此任务的信息，导致需要重新注册。那么只需要将老线程停止即可。
    JobThread oldJobThread = jobThreadRepository.put(jobId, newJobThread);	
    // 为什么调用了 toStop 方法后还要调用 interrupt呢？
    // 因为JobThread的run方法中有阻塞队列阻塞取值的功能，这里使用 interrupt打断阻塞，你都要死了，你取啥呢
    if (oldJobThread != null) {
        oldJobThread.toStop(removeOldReason);
        oldJobThread.interrupt();
    }

    return newJobThread;
}
// 将线程移除，同样是执行 toStop、interrupt
public static JobThread removeJobThread(int jobId, String removeOldReason){
    JobThread oldJobThread = jobThreadRepository.remove(jobId);
    if (oldJobThread != null) {
        oldJobThread.toStop(removeOldReason);
        oldJobThread.interrupt();

        return oldJobThread;
    }
    return null;
}
// 根据 任务id 获取执行这个任务的线程，然后可以使用 pushTriggerQueue将调度参数放入队列
public static JobThread loadJobThread(int jobId){
    return jobThreadRepository.get(jobId);
}
```

