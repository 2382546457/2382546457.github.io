---
title:  1. Sentinel中的一些概念与核心类解析
date: 2023-11-29 16:08:05
permalink: /pages/3d8a71/
---
## 1. 资源 ResourceWrapper

想要做限流、熔断，目标是谁？肯定是资源。资源可以是一个方法、一段代码、一个接口...

Sentinel 统计的数据以资源为维度，资源使用 ResourceWrapper 表示

```java
public abstract class ResourceWrapper {
	// 资源名
    protected final String name;
	// 节点类型，进入或流出
    protected final EntryType entryType;
    // 资源类型，比如MVC、Dubbo、grpc..
    protected final int resourceType;
}
```

- name ：资源名
- entryType ：此资源表示的节点的类型，即流入流量还是流出流量，通俗一点说就是发起请求还是接收请求。
- resourceType ：资源类型，Sentinel 集成了很多框架，不同的资源之间还会相互调用，所以要分清楚。

EntryType 是一个枚举类 ：

```java
public enum EntryType {
    IN("IN"),
    OUT("OUT");
}
```

Sentinel1.8.1 支持的 resourceType 有以下几种 ：

```java
public final class ResourceTypeConstants {

    public static final int COMMON = 0;
    public static final int COMMON_WEB = 1;
    public static final int COMMON_RPC = 2;
    public static final int COMMON_API_GATEWAY = 3;
    public static final int COMMON_DB_SQL = 4;

    private ResourceTypeConstants() {}
}
```

- COMMON ：不集成任何框架
- COMMON_WEB ：集成web应用的接口
- COMMON_RPC ：rpc接口
- COMMON_API_GATEWAY ：用于 API GateWay 网关
- COMMON_DB_SQL ：数据库SQL操作

综上所述，Sentinel 中的资源可能的类型有

- 进入程序的web请求
- 程序发出的rpc请求
- 程序发出的sql操作
- .......

## 2. 节点 Node

Sentinel 中的每一个资源都可以成为一个 Node，至于成为哪一个 Node 要看使用情况。

Node 作为 Sentinel 中持有实时统计数据的接口，它定义了一个节点所需要提供的各项指标数据统计功能，为外部屏蔽统计数据的实现。

```java
public interface Node extends OccupySupport, DebugSupport {
    long totalRequest(); // 获取总的请求数
    long totalPass(); // 获取通过的请求总数
    long totalSuccess(); // 获取成功的请求总数
    long blockRequest(); // 获取被 Sentinel 拒绝的请求总数
    long totalException(); // 获取异常总数
    double passQps(); // 通过 QPS
    double blockQps(); // 拒绝 QPS
    double totalQps(); // 总 qps
    double successQps(); // 成功 qps
    // 最大成功总数 QPS（例如秒级滑动窗口的数组大小默认配置为 2，则取数组中最大）
    double maxSuccessQps(); 
    double exceptionQps(); // 异常 QPS
    double avgRt(); // 平均耗时
    double minRt(); // 最小耗时
    int curThreadNum(); // 当前并发占用的线程数
    double previousBlockQps(); // 前一个时间窗口的被拒绝 qps
    double previousPassQps(); // 前一个时间窗口的通过 qps
    Map<Long, MetricNode> metrics(); 
    List<MetricNode> rawMetricsInMin(Predicate<Long> timePredicate);
    void addPassRequest(int count); // 添加通过请求数
    void addRtAndSuccess(long rt, int success); // 添加成功请求数，并且添加处理成功的耗时
    void increaseBlockQps(int count); // 添加被拒绝的请求数
    void increaseExceptionQps(int count); // 添加异常请求数
    void increaseThreadNum(); // 自增占用线程
    void decreaseThreadNum(); // 自减占用线程
    void reset(); // 重置滑动窗口
}
```

为啥 Node 是一个接口而不是实现类？因为要将 Sentinel 中的 “节点” 按照类型区分开。

比如有三个资源 ：a、b、c

这三个资源有以下调用链 ：

a -> b -> c

b -> c -> a

a -> b -> a

在三个调用链中，同一个节点充当了不同的角色，比如第三个调用链中，a 既是入口节点也是普通节点。

我们给它起名 ：`入口a`、`普通a`

同时如果要统计 “a” 这个资源的总访问量怎么办？难道要将全部的`入口a`、`普通a` 一个一个遍历相加？

不，创建一个`全局 a` ，流量进入 `入口a`、`普通a`时将不仅将对应的节点流量加一，还将全局a的数据也加一

现在有了三种节点，它们都是 Node 的子类：

- 入口节点 EntranceNode 
- 普通节点 DefaultNode 
- 全局节点 ClusterNode 

Sentinel 将这三种节点的共同属性 ：统计数据功能 抽取出来作为它们三个的父类。关系图如下：

![image-20231127200149326](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231127200149326.png)

- Node ：抽象类，提供规范
- StatisticNode ：提供了统计数据的功能。
- DefaultNode ：普通节点，
- EntranceNode ：入口节点
- ClusterNode ：全局节点，一个资源只能有一个全局节点。

一个资源可能有多个入口节点或普通节点，但是只能由一个全局节点。ClusterNode 与 DefaultNode 的关系是一对多。

接下来详细介绍各个类

### 2.1 统计节点 ：StatisticNode

```java
public class StatisticNode implements Node {
    // 秒级滑动窗口，2 个时间窗口大小为 500 毫秒的 Bucket
    private transient volatile Metric rollingCounterInSecond = new ArrayMetric(2,1000);
    // 分钟级滑动窗口，60 个 Bucket 数组，每个 Bucket 统计的时间窗口大小为 1 秒
    private transient Metric rollingCounterInMinute = new ArrayMetric(60, 60 * 1000, false);
    
    // 统计并发使用的线程数，可以根据线程数限流。
    private LongAdder curThreadNum = new LongAdder();
    
    // 实现了从 Node 继承过来的其他统计方法，这里列举几个简单的
    
    // 一分钟内成功放心的全部请求数量
    @Override
    public long totalPass() {
        return rollingCounterInMinute.pass();
    }
    
    // 成功放行了一个请求，加上。
    @Override
    public void addPassRequest(int count) {
        rollingCounterInSecond.addPass(count);
        rollingCounterInMinute.addPass(count);
    }

    // 。。。。。。其他的就不放了，StatisticNode实现了Node的所有抽象方法。
}
```

在一般情况下，Sentinel 使用滑动窗口算法统计经过每一个 Node 的资源。滑动窗口算法会在以后的文章介绍到。

通过实现 Node 规定的方法，StatisticNode 提供了统计秒级、分钟级成功请求数、失败请求数等等功能。

所有继承它的 Node ，也就是 ClusterNode、DefaultNode、EntranceNode 都具有这些功能。

注意 ：StatisticNode 只提供统计数据的功能，它不表示任何资源。

### 2.2 普通节点 ：DefaultNode

```java
public class DefaultNode extends StatisticNode {

    // 这个节点表示的资源
    private ResourceWrapper id;

    // 这个节点的全部子节点
    private volatile Set<Node> childList = new HashSet<>();
	
    // 该节点对应的 ClusterNode
    private ClusterNode clusterNode;


    @Override
    public void increaseBlockQps(int count) {
        super.increaseBlockQps(count);
        this.clusterNode.increaseBlockQps(count);
    }

    @Override
    public void increaseExceptionQps(int count) {
        super.increaseExceptionQps(count);
        this.clusterNode.increaseExceptionQps(count);
    }

    @Override
    public void addRtAndSuccess(long rt, int successCount) {
        super.addRtAndSuccess(rt, successCount);
        this.clusterNode.addRtAndSuccess(rt, successCount);
    }

    @Override
    public void increaseThreadNum() {
        super.increaseThreadNum();
        this.clusterNode.increaseThreadNum();
    }

    @Override
    public void decreaseThreadNum() {
        super.decreaseThreadNum();
        this.clusterNode.decreaseThreadNum();
    }

    @Override
    public void addPassRequest(int count) {
        super.addPassRequest(count);
        this.clusterNode.addPassRequest(count);
    }

    public void printDefaultNode() {
        visitTree(0, this);
    }
}
```

- id ：这个节点表示的资源。
- childList ：这个节点的全部子节点
- clusterNode ：该节点对应的 ClusterNode。

资源与节点之间是一对多的关系。资源与ClusterNode之间是一对一的关系。

一个 DefaultNode 可以有多个子节点形成如下的结构 ：

（其实最顶端的 A 不是 DefaultNode，这里只是做一个比喻）

![image-20231127202958197](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231127202958197.png)

<font color=Blue>多个 DefaultNode 就形成了一棵树</font>

注 ：了解 Sentinel 的就能看出来这颗树还有很多缺陷，但是现在只是做一个比喻。

同时，通过源码你可能看出来了，DefaultNode 在执行放行请求方法时如下：

```java
@Override
public void addRtAndSuccess(long rt, int successCount) {
    super.addRtAndSuccess(rt, successCount);
    this.clusterNode.addRtAndSuccess(rt, successCount);
}
```

先给自己的数据记录一下，再给自己所属的 ClusterNode 记录一下，跟咱们之前说的一样。

### 2.3 入口节点 ：EntranceNode

入口节点没有变量，功能被 StatisticNode 实现了，变量被 DefaultNode 拥有了，EntranceNode 就特别简洁了：

```java
public class EntranceNode extends DefaultNode {

    public EntranceNode(ResourceWrapper id, ClusterNode clusterNode) {
        super(id, clusterNode);
    }
}
```

EntranceNode 与 DefaultNode 的区别是重写 StatisticNode 的方法不一样。这个以后再说。

### 2.4 全局节点 ：ClusterNode

```java
public class ClusterNode extends StatisticNode {
	// 节点名，即资源名，其实应该使用 ResourceWrapper的，不知道这里为啥用了String
    private final String name;
    // 资源类型
    private final int resourceType;

    // 维护每个调用来源的指标数据统计数据（StatisticNode），用途是什么，在使用到时再做分析。
    private Map<String, StatisticNode> originCountMap = new HashMap<>();
    
	// 控制并发修改 originCountMap 用的锁
    private final ReentrantLock lock = new ReentrantLock();
}
```

- name ：资源名，其实应该使用 ResourceWrapper的，不知道这里为啥用了String
- resourceType ：资源类型
- originCountMap ： 维护每个调用来源的指标数据统计数据（StatisticNode）
- lock ：控制并发修改 originCountMap 用的锁

其实它还有一个方法用来操作 originCountMap 的，这里我还没有搞懂就不说了。

将 Node 总结一下来个大图 ：

![image-20231127215501416](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231127215501416.png)

## 3. Entry

在认识 资源 和 节点 之后就该 Entry 了，Entry是由 节点+调用链 组成。

Sentinel 提供的是限流、熔断功能，具体来说就是热点限流、系统限流、来源限流.... 这些功能通过责任链模式组成了一个调用链，由于每一个资源都需要进行判断，每一个资源要的限流规则都有差别，所以每一个资源都要走一遍调用链，Sentinel 使用 Entry 将 节点和调用链 封装起来。

听起来是不是特别麻烦？确实，要做到每一个资源都进行限流确实特别麻烦。

```java
public abstract class Entry implements AutoCloseable {
    // 创建时间
    private long createTime;
    // 当前节点（DefaultNode）
    private Node curNode;
    // 来源节点
    private Node originNode;
    // 错误
    private Throwable error;
    // 资源id
    protected ResourceWrapper resourceWrapper;
}
```

CtEntry 是 Entry 的直接子类，后面分析源码时，我们所说 Entry 皆指 CtEntry。CtEntry 中声明的字段信息如下代码所示。

```java
class CtEntry extends Entry {
    // 当前 Entry 指向的父 Entry
    protected Entry parent = null;
    // 父 Entry 指向当前 Entry
    protected Entry child = null;
    // 当前资源的 ProcessorSlotChain，责任链模式，也就是很多拦截器
    protected ProcessorSlot<Object> chain;
    // 当前上下文
    protected Context context;
}
```

为啥 Entry 要分父子关系 ？在 Node 章节中我们介绍了，多个 DefaultNode 可以组成树，我们一次只需要统计当前一条链路的 Node，也就是一个链表，所以这个 parent 和 child 其实也可以称作 pre 和 next。

<font color=blue>Entry 是一次调用形成的调用链上的节点</font>。

这张图描述了多个 Node 的关系

![image-20231127215501416](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231127215501416.png)

现在我们将 A -> B -> F 这条调用链来画一下 Entry

![image-20231127223419303](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231127223419303.png)

Entry 的存活时间是非常短的，只在执行时创建，执行结束销毁，所以 Entry存在于`一次执行`形成的调用链。

但是 Node 会一直存储此节点的流量状态，只要程序不重启 Node 就一直存在，并且资源越多，Node 越多。

每一个 Node 中统计的数据也会随着访问量的改变而改变。

## 4. 上下文 Context

很多框架都有一个上下文对象，Sentinel 也不例外。Sentinel 的 ContextUtil 使用 ThreadLocal 持有 Context，Context 存储的信息包括 ：

```java
public class Context {
    // Context的name
    private final String name;
    // 此次执行的入口节点
    private DefaultNode entranceNode;
    // 现在执行到哪个Entry了。
    private Entry curEntry;
    private String origin = "";
    
    // 我们不讨论异步的情况
    // private final boolean async;
}
```

- name：Context 的名称。
- entranceNode：当前调用树的入口节点，类型为 EntranceNode。同一个入口的资源，每个资源对应一个 DefaultNode，entranceNode#childList 用于存储这些资源的 DefaultNode。
- curEntry：当前 Entry（CtEntry）。
- origin：调用来源的名称，即服务消费者的名称或者服务消费者的来源 IP，取决于服务消费者是否使用 Sentinel，由 Sentinel 适配层传递过来。例如：服务提供者是 Spring MVC 应用，且服务提供者使用 Sentinel 的 Web MVC 适配，那么 Sentinel 会尝试从请求头获取”S-user”，如果服务消费者有在请求头传递这个参数，那么就能够获取到。

```java
public class ContextUtil {
    // 持有 Context
    private static ThreadLocal<Context> contextHolder = new ThreadLocal<>();
    // 持有所有 EntranceNode，即所有第一层Node
    private static volatile Map<String, DefaultNode> contextNameNodeMap = new HashMap<>();
    // 新建 Context 时的锁
    private static final ReentrantLock LOCK = new ReentrantLock();
}
```

如下代码：

```java
// 显示创建 Context
ContextUtil.enter("sentinel_spring_web_context");
Entry entry = null;
try {
     // 创建资源对应的 entry
     entry = SphU.entry("/user/get", EntryType.IN);
     // 执行业务方法
     return doBusiness();
} catch (Exception e) {
     if (!(e instanceof BlockException)) {
          Tracer.trace(e);
     }
     throw e;
} finally {
     if (entry != null) {
         // 销毁此entry, 会将 Context.curEntry改为entry.parent
         entry.exit(1);
     }
     // 销毁 Context
     ContextUtil.exit();
}
```

其实在 SphU.entry() 方法中也有新建 Context 的逻辑，但那是保底策略，SphU.entry() 会判断当前 Context 是否为空，如果为空就创建一个 Context(sentinel_default_context)，这是默认的 context，当与其他框架集成时都是显式的创建并指定 Context 的名字。

## 5. 根节点 Constants.ROOT

其实<font color=Blue>整个程序的 入口节点是固定的</font>，它存放在常量类 Constants 中。

```java
public final class Constants {
    // context默认的名称
    public final static String CONTEXT_DEFAULT_NAME = "sentinel_default_context";
    
    // 每一个程序默认的入口节点对应的 DefaultNode
    public final static DefaultNode ROOT = new EntranceNode(
        new StringResourceWrapper(ROOT_ID, EntryType.IN),
        new ClusterNode(ROOT_ID, ResourceTypeConstants.COMMON)
    );
    
    // 每一个程序默认的入口节点对应的全局节点
    public final static ClusterNode ENTRY_NODE = new ClusterNode(
        TOTAL_IN_RESOURCE_NAME, 
        ResourceTypeConstants.COMMON
    );

}
```

<font color=Blue>根节点的**第一层**子节点也是固定的</font>，它会根据不同的框架变换。什么意思？

也就是说，一整个程序的 Node 树的根节点其实是固定的，根节点下的第一层入口节点也是固定的，如果没有集成任何环境，那么第一层节点是 name = sentinel_default_context；如果集成了mvc，第一层节点是 name = sentinel_spring_web_context，集成了其他环境还会有其他的名字，现在 Node 树变为 ：

![image-20231128104011053](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231128104011053.png)
现在验证一下，我们不集成任何环境，那么 ROOT 下第一个 EntranceNode 就一定是 sentinel_default_context。

将 `abc` 当作资源的话，`abc`就会是 sentinel_default_context 的第一个子节点：

![image-20231128104421747](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231128104421747.png)

（使用 sentinel-demo/sentinel-demo-basic/flow/FlowQpsDemo 测试类）

这样做的好处是集成其他环境时很方便，坏处就是不好理解

总结一下 ：

- ROOT 并不参与 Context 的构建，Context 的 EntranceNode 都是 第一层节点。
- Entry 是调用链，第一层节点不参与 Entry 的构建

## 6. 插槽 ProcessorSlot

ProcessorSlot 直译就是处理器插槽，是 Sentinel 实现限流降级、熔断降级、系统自适应降级等功能的切入点。Sentinel 提供的 ProcessorSlot 可以分为两类，一类是辅助完成资源指标数据统计的切入点，一类是实现降级功能的切入点。

辅助资源指标数据统计的 ProcessorSlot：

- NodeSelectorSlot：为当前资源创建 DefaultNode，并且将 DefaultNode 赋值给 Context.curEntry.curNode；

    如果此 DefaultNode 是当前调用链路上第二个Node（因为第一个 Node 是固定的），将该 DefaultNode 添加到的 Context.entranceNode 的子节点，否则添加到 Context.curEntry.parent 的子节点（childList）。有点抽象，我们在分析 NodeSelectorSlot 源码时再详细介绍。

- ClusterBuilderSlot：如果当前资源未创建 ClusterNode，则为资源创建 ClusterNode；将 ClusterNode 赋值给当前资源的 DefaultNode.clusterNode；如果调用来源（origin）不为空，则为调用来源创建 StatisticNode，用于实现按调用来源统计资源的指标数据，ClusterNode 持有每个调用来源的 StatisticNode。

- StatisticSlot：这是 Sentinel 最为重要的类之一，用于实现指标数据统计。先是调用后续的 ProcessorSlot#entry 判断是否放行请求，再根据判断结果进行相应的指标数据统计操作。

实现降级功能的 ProcessorSlot：

- AuthoritySlot：实现黑白名单降级
- SystemSlot：实现系统自适应降级
- FlowSlot：实现限流降级
- DegradeSlot：实现熔断降级

Sentinel 使用责任链模式将这些插槽组成了拦截器链条，之前我们称 ProcessorSlot 为拦截器，现在要改口为插槽了

- ProcessorSlot ：插槽，每一个插槽有不同的功能，比如系统限流、黑白名单限流、熔断降级。
- ProcessorSlotChain ：内含头插槽和尾插槽，将所有插槽组成插槽链执行。

关于每个 ProcessorSlot 是如何组成链表、如何实现的功能，将在后续文章详细分析。