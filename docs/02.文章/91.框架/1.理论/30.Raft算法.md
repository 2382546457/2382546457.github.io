## 1. 简述

什么是 Raft 算法，撇开内容不说，它是一种分布式算法，这个算法是干啥的呢？

如果我们要搭建 Nacos 集群，那么多个 Nacos 之间如何互通数据呢？谁来当主节点？主节点宕机怎么办？再选举一个主节点？怎么选举？选举之后主节点与从节点的数据不一致怎么办？

这些问题在 Raft 算法中都有解决方案，但是这些具有存储能力的中间件一定要对 Raft算法 完完全全的实现吗？

那肯定不是，快速排序也是一种算法，在快速排序的基础上人们又实现了多路快速排序，又由于选择基准点不同，不同人实现的快速排序也不一样，Raft 算法也是同理，虽然它对分布式系统给出了一个大致的方向，但是各个中间件在实现方面又各有差异。

现在来介绍一下什么是 Raft。

私你马赛，先来推荐一个B站视频 ：[【动画：Raft算法Leader选举、脑裂后选举、日志复制、修复不一致日志和数据安全】 ](https://www.bilibili.com/video/BV1so4y1r7eM/?share_source=copy_web&vd_source=1d9935400799240a10a2036e25bfe04e)

接下来是本篇文章涉及到的图片的地址 ：[https://raft.github.io/](https://raft.github.io/)

## 2. Raft 基本知识

在这一标题中，会涉及到 Raft算法 实现中的一些名词。

### 2.1 节点类型

遵循 Raft算法 的分布式集群中每个节点扮演以下三种角色之一 ：

1. Leader ：领导者。负责和客户端通信，接收来自客户端的命令并发给 Follower，创建日志、与 Follower 同步日志。
2. Follower ：跟随者，其一丝不苟的执行来自 Leader 的命令，可以投票给 Candidate 使其成为 Leader。
3. Candidate ：候选者，当 Follower 长时间没有接收到 Leader 的消息时，Follower就会揭竿而起成为候选者。

解释一下 ：在 Raft 系统中并没有固定的 Leader，每一个节点都有成为 Leader 的机会。

当长时间没有 Leader 给自己发消息时，Follower 会认为此时没有 Leader，王侯将相宁有种乎？这次我当Leader！此 Follower 就成为 Candidate，给其他的 Follower 发送拉票请求。至于其他的 Follower 同意与否，这个等会再说。如果有一半以及以上的节点同意自己当 Leader，那就翻身做地主了。

万一有一个 Follower 通过选举成为 Leader，那么它会每一个周期给所有 Follower 发送心跳，告诉他们老大还在，你们不要太猖狂。

### 2.2 任期

Raft算法将 Leader的当选 分为一个个任期（term），每一个任期的开始都是 Leader 选举。

每一个任期一一次选举作为起点，所以当一个节点成为 Candidate 并向其他节点拉票时，会将自己的 Term 加1，表明新一轮任期的开始以及旧 Leader 的任期结束。所有节点在收到比自己更大的任期（Term）之后就会更新自己的 Term 并转成它的 Follower，如果任期比自己小则拒绝投票。

每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；

- 如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。
- 如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。
- 如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。

### 2.3 投票

Raft算法中，投票指的是 Follower 投给 Candidate ，表示自己愿意让这个 Candidate 成为 Leader 。

这个“票” 指的是一个 RequestVote RPC 调用，用人话就是发了一次请求，这个请求中包含以下数据：

1. Candidate 的 Term
2. Candidate 的 ID
3. Candidate 的 最后一条日志的 Index
4. Candidate 的 最后一条日志的 Term

收到拉票请求的节点，会根据如下规则判断是否会将票投给这个拉票人：

1. 判断该 Candidate 的 Term 是否更大，不是则说明是旧消息，拒绝该请求。
2. 如果任期 Term 相同，则比较各自日志的 Index，Index 越大说明数据越新，你的日志还没我新就想让我支持你当老大？

## 3. Leader 的选举

最初所有的节点都是 Follower，并且每一个节点都会生成一个随机等待时间，在这个等待时间结束之前还没有 Leader 给我发来消息，那我就变成 Candidate 向其他节点拉票。

![等待时间未结束](https://typorehwf.oss-cn-chengdu.aliyuncs.com/20231103160906.png)

图中的 S1、S2...代表节点名，圆圈内部的数字 1 代表任期号（Term）。圆圈外面那层灰色进度条代表随即等待时间。

可以看到 S1 的等待时间已经快结束了。等待时间一旦结束，S1 会成为 Candidate，并且：

- 将自己的任期加一
- 给自己投一票，再向其他节点拉票，发送 RequestVote RPC

![S1拉票](https://typorehwf.oss-cn-chengdu.aliyuncs.com/20231103161206.png)

如图，S1 的任期变为 2，内部多了 一个实心黑圈和四个空心白圈，代表现在只有一票，是自己投的。

S2、S3、S4、S5 在收到这个拉票请求后，由于此时没有日志，那么只比较任期Term。很明显 S1 更胜一筹。

那么不出意外的情况下， S2、S3、S4、S5 都支持 S1 当选 Leader。

但是不出意外的话要出意外了：

S3、S4、S5 都支持 S1 当选 Leader。只有 S2 不支持，为什么？因为 S2 的等待时间结束了，它也要成为 Candidate 进行拉票了。

## 4. 投票分裂

其他节点在接收到 S1 发送的拉票请求后，发现 S1 的 Term 比自己大，于是欣然同意 S1，并将自己的任期与 S1 进行同步。

但是！S2 成为了 Candidate，Term 变成2，跟S1的任期一样，所以拒绝了 S1 的拉票并向所有节点发送拉票请求：

![出现投票分裂情况](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103162943273.png)

图中的 RequestVote RPC 挺多挺乱的，一共有两种消息，

1. 一种是 同意/拒绝S1拉票 的请求。
2. 一种是 S2 向其他节点发送的拉票请求。

那么 S2 发送的拉票请求一定不会成功，因为其他节点的任期跟它一样，所以不会投给它。

并且此时 S1 已经成为了 Leader，会发送心跳告知其他节点。

![S1成为Leader](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103163434532.png)

当 S1 的 Leader 心跳到达其他节点后，他们就都变为 Follower。

需要注意的是，每一次接收到来自 Leader 的心跳，Follower 都必须更新自己的等待时间，重新等。但是如果在等待时间结束的时候还没有 Leader 的心跳，说明它死了，我可取而代之。

## 5. 日志复制

虽然说是日志，其实在我们的实现中复制的也可以是数据，所以这一部分很重要。

在前面的叙述中，S1 已经当选了 Leader，这时它接收到了用户产生的数据，如下：

![S1日志](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103164846457.png)



S1 现在有三条日志，日志的产生时机是2，代表这条日志产生时的任期为2。为什么是虚线呢？

我们可以将虚线日志看作为 还存在于内存中的数据，在半数节点统一内存中的数据后才能刷新到磁盘。

那么日志同步就是 Leader 中产生的日志，发送给 Follower 去同步，如果同步成功就给 Leader 返回成功。

如果一个日志同步请求得到多数 Follower 的成功，这个日志将会被写入状态机（写入磁盘）。Leader 将日志写入磁盘后也会通知 Follower 让他们将此条日志写到磁盘。

这里需要介绍两个变量 ：这两个变量要用于日志同步。

1. next index ：下一个需要同步的日志下标。
2. match index ：可以写入磁盘的最大下标。

在图里的表现形式是 ：箭头是 next index；圆点是 match index

补充到现在，来看看Leader 发送给 Follower 的请求中都有哪些数据？

1. Leader 的 next index 位置的日志
2. Leader 的 match index，表示所有 Follower 可以将 match index 前的数据都写入磁盘。

复制 Index 为 1 的日志 ：可以看到 S2、S3、S4、S5 都应用了这条日志。那么 Leader 接收到所有返回后，将会把 Index 为 1 的日志写入磁盘。

![复制 Index 为 1 的日志](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103165358599.png)

由于超半数节点都同意将 index = 1的日志同步进内存。于是S1下一条消息就是

- next index ：2
- match index ：1

其他节点在接收到这个消息时，如果同意，会将 next index 日志复制到内存中，match index 的日志写入磁盘中。

![image-20231103170615154](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103170615154.png)

## 6. 修复不一致的日志

如果在这种情况下，S1 宕机了怎么办？也就是 S1 还有很多日志没有同步到其他节点，其他节点同样有部分日志没有写入磁盘，这时 S1 宕机了怎么办呢？

![image-20231103170953329](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103170953329.png)

由于 S1 宕机，肯定要重新选举：

![image-20231103171106053](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103171106053.png)

在此处选举中，S3 成为了 Leader ：

![image-20231103171202376](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103171202376.png)

来捋一捋所有节点的情况：

- S1 ：宕机

- S2 ：已写入日志有两条，还有一条没写入
- S3 ：已写入日志有一条，还有两条没写入
- S4 ：已写入日志有两条，还有一条没写入
- S5 ：已写入日志有两条，还有一条没写入

新的 Leader 要做的第一件事就是初始化所有 next index ，与自己保持一致。接下来 S3要开始做一致性检查了。

检查的内容是 ：Follower 的 next index 位置的日志与自己是否一致，如果不一致，Follower 的 next index 前移，一直移到一致或者next index = 0。此时开始从 next index 同步日志。

并且 S3 开始生成自己任期内的日志，也就是 Term 为 3 的日志，并让 Follower 进行同步：

![image-20231103172057856](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103172057856.png)

但是此时 S1 又苏醒过来了咋办？

首先，S3 成为了 Leader，S1 的 Term 没有 S3 大，肯定不会再是 Leader。

然后，S1 的日志从 4 开始与 S3 不一致，就开始修复不一致的日志，按照刚才说的顺序：

1. S3 将自己的 next index 发给 S1 ，S1 将 next index 改为 6
2. S1 返回对比自己 next index 位置的日志与 S3 next index 位置的日志是否一样，不一样就往前减一个继续对比
3. 直到对比到 next index 为 3 ，终于一样了！于是开始数据同步。

![image-20231103172443405](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103172443405.png)

上图是 S1 已经将所有数据与 S3 达到同步的状态。可以看到，Raft 算法是以 Leader 为主的强一致性算法。

## 7. 保证数据安全

上面说 Raft 算法是以 Leader 为主的强一致性算法。那么如果出现以下情况：

![image-20231103181717099](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103181717099.png)

先说一下是什么情况吧，在 S1、S2、S3、S4 开心愉悦的工作期间，S5一直处于宕机状态，所以 S5 一条日志都没有。但是此时 S1 宕机了，万一让 S5 当上了 Leader，S5 肯定要进行数据同步，难道让它将其他节点的数据全部清除吗？

肯定不可以，别说让它同步数据了，就连 Leader 都不能让它当。还记得之前说的 “投票”吗？

![image-20231103182058362](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231103182058362.png)

S5 苏醒之后，首先它的 Term 就一定没有其他节点大，根本没有它当 Leader 的机会。

其次，就算你的 Term 侥幸跟其他节点一样大了，但是你日志的Term没有其他节点大，其他节点根本不会投你啊。

