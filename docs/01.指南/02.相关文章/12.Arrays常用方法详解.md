---
title: Arrays常用方法详解
date: 2023-06-08 19:06:57
permalink: /pages/70b8f5/
article: false
---
## 1. Arrays.toString()方法

方法作用：快速输出数组内容，可以偷偷懒🌚

```java
int[] a = {1,2,3,4,5};
System.out.println(Arrays.toString(a));
// 输出格式：[1,2,3,4,5]
```

## 2. Arrays.sort()方法

方法运用:给数组排序，默认升序

```java
int[] a = new int[5]{5，4，3，2，1};
Arrays.sort(a); // 1 2 3 4 5
System.out.println(Arrays.toString(a));
// [1,2,3,4,5]
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

两种重载方式：

**①.Arrays.sort(数组名)**

![image-20221201110415225](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201110415225.png)

 **②.Arrays.sort(数组名，起始下标，排序个数)**

```java
Scanner s = Scanner(System.in);
int n = s.nextInt();
int[] a = new int[n]
for(int i = 0; i < n; i++)
   a[i] = s.nextInt();
Arrays.sort(a,0,n - 1);
//输入n个数，按照升序排列
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

对字符串进行排序时，是对每一个字符比较，而不是简单的比较长度

```java
// str1 = abd
// str2 = abcdef
// 因为d > c,所以 str1 > str2
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

它是一个很强大的方法，具体见博文：[浅谈Arrays.sort()原理](https://blog.csdn.net/Duuuhs/article/details/89167231?utm_source=app&app_version=5.3.0&code=app_1562916241&uLinkId=usr1mkqgl919blen)

## 3.Arrays.equals()方法

方法作用：比较两个数组内容是否相等

```java
int[] a = {1,2,3};
int[] b = {1,2,3};
boolean isSame = Arrays.equals(a,b);
//true
```

> 注意：Arrays.equals(a, b)是比较`数组内容`，而a.equals(b) 这样的方法是比较`地址值`

因为数组也是引用数据类型，所以它的父类也是Object，它调用equals()是调用Object.equals()。

Arrays.equals() 实现了比较数组内容是否相同的功能。

>虽然也这个无关，但是还是要提醒一下：
>
>以后比较引用数据类型时，要使用Java提供的equals()，或者自己实现equals()，而不是 ==

## 4.Arrays.binarySearch()

方法作用：在数组中查找元素

```java
int Arrays.binarySearch( Datatype[], Datatype key)
```

在数组中查找指定值，若找到，则返回此值的下标，

若没找到，返回 `-插入点 - 1`；

对于一个数组：1 2 4

3的插入点就是2与4之间，下标为2，此处就应返回 -2-1 = -3。

更多示例如下：

```java
int[] a = {1,5,6,7};
Arrays.binarySearch(a,2)  //没找到，插入点为1，则返回 -2
Arrays.binarySearch(a,4)  //没找到，插入点为1，则返回 -2
Arrays,binarySearch(a,8)  //没找到，插入点为4，则返回 -5
Arrays.binarySearch(a,5)  //找到了！返回下标 1
只要返回值 ≥ 0 ，就代表找到了。
```



## 5.Arrays.copyOf()

方法作用：拷贝数组

源码如下：第一个参数是`原数组`，第二个参数是`拷贝长度`，返回值是将原数组拷贝一份返回

（它的底层其实是调用了System.arrayCopy()方法）

```java
public static <T> T[] copyOf(T[] original, int newLength) {
      return (T[]) copyOf(original, newLength, original.getClass());
}
```



需要注意的是返回值是一个新数组，会改变接收这个新数组的引用的一些属性 

```java
public static void main(String[] args) {
        int[] arr1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int[] arr2 = new int[5];
        arr2 = Arrays.copyOf(arr1, 10);
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![image-20221201111211412](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201111211412.png)

 Arrays.copyOf()的拷贝是从下标0开始的，如果你想从其他下标开始，可以使用Arrays.copyOfRange()方法

```java
// from 表示开始位置， to 表示结束位置  
// 复制下标为 ：[from, to)
Arrays.copyOfRange(int[] original, int from, int to)
```

![image-20221201111308147](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201111308147.png)

## 6. 补充：Arrays.sort()降序排列

Arrays.sort()固然强大，但是我们有些特殊需求它无法完成：

1. 对一个整数数组进行逆序排序。由大到小。

2. 按学生的学号排序，如果学号相同，按照年龄排序。

这时就需要自定义排序规则。

Arrays.sort() 的自定义排序规则有一个特点：

> 不能作用于基本数据类型！

 那你说，我要是想对：{8，6，5，3，2} 排序，用什么类型呢？这些数据都是int啊，不能降序怎么办？那当然是使用我们的包装类 Integer、Double、Float 了啊。

为什么不能用于基本数据类型呢？等会你就知道了

先看看最简便的写法：

### Collections.reverseOrder()

```java
Integer[] a = {1,2,3,4,5}
Arrays.sort(a,Collections.reverseOrder())
// 输出数组的内容即为：5 4 3 2 1
```

来看看如果用int类型数组会发生什么：

![image-20221201112540975](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201112540975.png)

它会提示你：“需要的是一个泛型T[]，而不是int[]” （这里不做讲解，你只要知道不能int就行了）

直接在数组后面跟上：Collections.reverseOrder()，非常简便，至于原理？向下看。

### 实现Comparator接口

Java为我们提供了一个接口`Comparator`，实现它，重写它的compare(a, b)就能实现自定义规则。

首先确定我们要对什么样的数据排序，这里使用Integer那么就要实现`Comparator<Integer>`，

![image-20221201112928934](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201112928934.png)

compare有两个参数，一个返回值。

在每一次比较中，如果返回值大于0，二者交换顺序，如果小于/等于零，顺序不变。

这样说太空洞，还是要举例子：

```java
3 1 2 5 
```

第一次比较的两个参数是a = 3 和b =  1，在默认情况下，a - b = 3 - 1 大于0，交换顺序，变为 1 ，3。

这样慢慢就能实现升序排列，那么我们使用 b - a = 1 - 3 小于0，就不变，慢慢就能实现降序排列。

规则：前减后，升序；后减前，降序。

>所以刚才我们说的`基本数据类型不能自定义排序规则`你知道为什么了吗？
>
>因为Comparator需要知道你对什么类型的数据排序，就需要你填入一个泛型，而泛型是不能为基本数据类型的。

那么我们如何实现 ：学生有姓名、学号、年龄，按学生的学号排序，如果学号相同，按照年龄排序

贴上代码：

```java
class Student {
    public String name;
    public Integer id;
    public Integer age;
}


class MyComparator implements Comparator<Student> {

    @Override
    public int compare(Student o1, Student o2) {
        if (o1.id != o2.id) {
            return o1.id - o2.id;
        } else {
            return o1.age - o2.age;
        }
    }
}
```

你是否能完成：按学生的学号升序排序，如果学号相同，按照年龄降序，年龄大的在前面。



### 实现接口之 匿名内部类

这是补充，上面那个实现comparator接口的方法实在太过繁琐，我们还要为此创建一个类来重写conpare方法，这里给出一个简便的写法，名为`lambda表达式`，这个大家后面会接触到，现在可以先用用：

```java
Integer[] arr = new Integer[]{10, 4, 1, 7, 2};
Arrays.sort(arr, (a, b) -> b-a);
```



## Arrays.equals()的补充

为什么 Arrays.equals(a,b) 和 a.equals(b) 不同呢

因为：

> 数组是Object的子类，a.equals(b) 使用的是 Object 类的 equals 方法，是比较地址值的
>
> 而 Arrays 的equals()方法与Object的不同，它能够进行数组内容的比较

先来看看Object类的equals()方法：直接比较了 this 和 obj 的地址：

![image-20221201115340009](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201115340009.png)

再看看Arrays重写的equals()方法：比上面的复杂，就不一一讲解了

![image-20221201115355500](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201115355500.png)

用代码实验一下

![image-20221201115415086](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20221201115415086.png)

 可以看到，a.equals(b) 和 a == b   的结果是相同的 而Arrays.equals()才是比较数组内容是否相同的正确方法

再次强调：

> 以后使用java提供的引用数据内容(数组、字符串、各种集合....)时，一定要用equals()方法比较内容是否相等，而不是傻傻的用 ==了！因为官方已经把equals()给重写了。如果你要比较你自己写的类，例如学生按成绩排序，就要自己重写equals()方法